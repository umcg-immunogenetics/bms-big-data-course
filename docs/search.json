[
  {
    "objectID": "scRNA-seq.html",
    "href": "scRNA-seq.html",
    "title": "Single-cell RNA-seq data analysis",
    "section": "",
    "text": "Single-cell RNA-seq data analysis usually follows the steps shown in the figure below. The first step is the generation of the count matrices using the raw sequencing data. After that we start the quality control steps that can include removal of doublets, ambient RNA correction, and removal of low quality cells (i.e. high mitochondrial content (dying cells) and low number of reads (empty droplets)). Once we have a filtered and high quality dataset, we proceed to the pre-processing steps that include normalization, feature selection, dimensionality reduction, and clustering of the cells (explained with more details later).\n\n\n\nOverview of analysis steps for scRNA-seq. Heumos, L., Schaar, A.C., Lance, C. et al. Best practices for single-cell analysis across modalities. Nat Rev Genet 24, 550–572 (2023).\n\n\nFor the sake of simplicity and time, we will skip the quality control steps that precede any analysis done with scRNA-seq data. If you want to know more about the quality control steps you can check here and here. Therefore, here we will use a dataset that has already been quality controlled and filtered.",
    "crumbs": [
      "Single-cell RNA-seq data analysis"
    ]
  },
  {
    "objectID": "scRNA-seq.html#introduction",
    "href": "scRNA-seq.html#introduction",
    "title": "Single-cell RNA-seq data analysis",
    "section": "",
    "text": "Single-cell RNA-seq data analysis usually follows the steps shown in the figure below. The first step is the generation of the count matrices using the raw sequencing data. After that we start the quality control steps that can include removal of doublets, ambient RNA correction, and removal of low quality cells (i.e. high mitochondrial content (dying cells) and low number of reads (empty droplets)). Once we have a filtered and high quality dataset, we proceed to the pre-processing steps that include normalization, feature selection, dimensionality reduction, and clustering of the cells (explained with more details later).\n\n\n\nOverview of analysis steps for scRNA-seq. Heumos, L., Schaar, A.C., Lance, C. et al. Best practices for single-cell analysis across modalities. Nat Rev Genet 24, 550–572 (2023).\n\n\nFor the sake of simplicity and time, we will skip the quality control steps that precede any analysis done with scRNA-seq data. If you want to know more about the quality control steps you can check here and here. Therefore, here we will use a dataset that has already been quality controlled and filtered.",
    "crumbs": [
      "Single-cell RNA-seq data analysis"
    ]
  },
  {
    "objectID": "scRNA-seq.html#initial-set-up",
    "href": "scRNA-seq.html#initial-set-up",
    "title": "Single-cell RNA-seq data analysis",
    "section": "Initial set-up",
    "text": "Initial set-up\n\nSet working directory\nIn this step, you set your working directory, that is, the folder in your computer where you are going to save your scripts, data and results.\n\npath &lt;- '/Users/nvribeiro/Library/CloudStorage/OneDrive-UMCG/Desktop/PhD/Others/BMS-BigData-Course-2025' # you need to change this to your own path\n\nsetwd(path)\n\n\n\nLoad libraries\nIf you haven’t done, check the file “Preparation for data analysis – Big Data Course BMS 2025” and follow the instructions to install/update R, RStudio and the packages that you will used in the analysis. Then load the libraries.\n\nlibrary(Seurat)\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(patchwork)\nlibrary(stringr)\nlibrary(MAST)\nlibrary(ggrepel)\nlibrary(clusterProfiler)\nlibrary(org.Hs.eg.db)\nlibrary(enrichplot)\nlibrary(knitr)\nlibrary(presto)\nlibrary(forcats)\n\n\n# Optional: define a default theme to be used in all plots\ndefault_theme &lt;- function(){\n  theme_bw() +\n    theme(panel.grid = element_blank(),\n          panel.border = element_rect(linewidth = 1),\n          axis.title = element_text(size = rel(1)),\n          axis.title.y.left = element_text(margin = margin(r = 10, unit = 'pt')),\n          axis.title.y.right = element_text(margin = margin(l = 10, unit = 'pt')),\n          axis.title.x.bottom = element_text(margin = margin(t = 10, unit = 'pt')),\n          plot.title = element_text(size = rel(1), hjust = 0.5, face = 'bold'),\n          axis.text = element_text(size = rel(1)),\n          axis.ticks.length = unit(5, 'pt'),\n          strip.background = element_rect(fill = \"#f5a9a9\", linewidth = 0),\n          strip.text = element_text(size = rel(1), color = \"black\")\n    )\n}\n\n\n\nLoading the tutorial data\nWe will use a small subset of 10,000 single-cells from small intestine biopsies of pediatric samples from the Gut Cell Atlas by Elmentaite at al. (2021). This dataset is included in the files you downloaded previously and is called “Elmentaite_2021_P_smallInt_BMS_tutorial.rds”.\n\nobj &lt;- readRDS(\"data/Elmentaite_2021_P_smallInt_BMS_tutorial.rds\")\nobj\n\nAn object of class Seurat \n33538 features across 10000 samples within 1 assay \nActive assay: RNA (33538 features, 0 variable features)\n 2 layers present: counts, data\n\n\nThe code above loads the dataset and tells us that this is a Seurat object with 10,000 cells and 33,538 features (genes), and we are working with a RNA assay. Now we can start pre-processing this data and run some analysis.",
    "crumbs": [
      "Single-cell RNA-seq data analysis"
    ]
  },
  {
    "objectID": "scRNA-seq.html#pre-processing",
    "href": "scRNA-seq.html#pre-processing",
    "title": "Single-cell RNA-seq data analysis",
    "section": "Pre-processing",
    "text": "Pre-processing\nSingle-cell RNA-sequencing is prone to many different sources of variance, for example cells can have very different numbers of gene counts because of differences in the amount of mRNA present in them or purely randomly during the sequencing. Normalization of counts make the transcriptome profile of all cells comparable among them. During this process, you also want to remove unwanted sources of variation, for example genes involved in cell cycle or mitochondrial genes. If you want to know more about normalization, you can read this.\nMoreover, the counts matrix is huge and sparse (contains a lot of zeros), which means that not every detected gene is biologically informative. The features selection step is useful to reduce the computational power required and make sure the analysis focus only on informative genes. These genes ideally explain the biological variation in the data by prioritizing genes the vary between subpopulations, instead of within a subpopulation. These genes are then used to perform dimensionality reduction, which in this case is a principal component analysis (PCA). Using the PCA dimensions, we can then group cells into clusters based on how similar they are in this multidimensional space and visualize them in a UMAP representation.\nThe code below takes care of perform all the steps above. The resolution parameter in the function FindClusters() below is the one you need to pay more attention and adjust according to your dataset. A large value will lead to more clusters, and a small one, to fewer. The best way to guess the resolution parameter is to have some idea of how many cell types you expect in your sample based on the tissue you are working it, and then try different values until you find one that gives you a reasonable number of clusters. In this case, we are working with small intestine, a tissue with many different cell types, so we expect to have many different clusters. In the original publication, they have hundreds of different cell types but because we are working only with a small subset of the data and a low resolution to speed thing up a bit, so we will have much less.\n\noptions(future.globals.maxSize = 8000 * 1024^2)\n\nobj &lt;- obj %&gt;% \n  NormalizeData() %&gt;%\n  FindVariableFeatures() %&gt;%\n  ScaleData(vars.to.regress = \"pct_counts_mt\") %&gt;% # Regresses out the percentage of mitochondrial RNA\n  RunPCA() %&gt;%\n  FindNeighbors(dims = 1:50) %&gt;%\n  FindClusters(resolution = 0.3) %&gt;%\n  RunUMAP(dims = 1:50)\n\nWarning: The `slot` argument of `SetAssayData()` is deprecated as of SeuratObject 5.0.0.\nℹ Please use the `layer` argument instead.\nℹ The deprecated feature was likely used in the Seurat package.\n  Please report the issue at &lt;https://github.com/satijalab/seurat/issues&gt;.\n\n\nWarning: The `slot` argument of `GetAssayData()` is deprecated as of SeuratObject 5.0.0.\nℹ Please use the `layer` argument instead.\nℹ The deprecated feature was likely used in the Seurat package.\n  Please report the issue at &lt;https://github.com/satijalab/seurat/issues&gt;.\n\n\nRegressing out pct_counts_mt\n\n\nCentering and scaling data matrix\n\n\nPC_ 1 \nPositive:  IGFBP7, CALD1, IFITM3, SPARC, COL1A2, COL3A1, A2M, C1S, RARRES2, COL6A2 \n       SPARCL1, COL1A1, COL6A1, C1R, DCN, CXCL14, MFAP4, LUM, LGALS1, MMP2 \n       TIMP1, TM4SF1, COL4A2, COX7A1, NUPR1, IGFBP4, TPM2, ADAMDEC1, MYL9, GPX3 \nNegative:  IGHM, TCL1A, HLA-DQA1, DUSP2, KLRB1, TRBC1, CCL5, HMGA1, LRMP, PIM2 \n       HLA-DPB1, MZB1, IGKC, GPR183, HLA-DPA1, SRGN, LINC01857, RGS13, NKG7, LINC01871 \n       FAM30A, SPIB, ITGB2, IL7R, CST7, IGLC3, IGLC2, DERL3, TNFRSF17, TRGC2 \nPC_ 2 \nPositive:  ALDOB, FABP2, ANPEP, PRAP1, GUCA2A, DPEP1, FABP1, PHGR1, AMN, CDHR5 \n       SMIM24, APOB, C19orf33, MEP1A, RBP2, SI, EPCAM, CES2, MTTP, PCK1 \n       ACE, C3orf85, FABP6, AOC1, ENPEP, MGAM, KRT19, SERPINA1, CDHR2, MYO1A \nNegative:  VIM, CALD1, LGALS1, IGFBP7, COL6A2, RARRES2, COL1A2, COL3A1, C1S, SPARC \n       COL6A1, A2M, COL1A1, TIMP1, DCN, C1R, MMP2, CXCL14, TPM2, NUPR1 \n       SPARCL1, LUM, IFITM3, MFAP4, TCF4, SELENOM, C11orf96, IGFBP5, SOD3, SERPING1 \nPC_ 3 \nPositive:  PLVAP, ADGRL4, PCAT19, VWF, RAMP2, RAMP3, ECSCR, CYYR1, EGFL7, CLDN5 \n       CD34, JAM2, CDH5, PECAM1, FLT1, MMRN2, ESAM, CD93, PCDH17, PTPRB \n       TM4SF18, APLNR, PODXL, CALCRL, CD320, SOX18, ROBO4, FAM110D, MYCT1, TMEM88 \nNegative:  DCN, COL3A1, COL1A2, LUM, MFAP4, CXCL14, C1S, ADAMDEC1, FBLN1, RARRES2 \n       TCF21, COL1A1, CFD, EMILIN1, COL6A3, CCL11, MEG3, COL6A2, MMP2, CTSK \n       APOE, PDGFRA, C1R, CXCL1, CYGB, COL6A1, SPON2, HAPLN1, ABCA8, EDIL3 \nPC_ 4 \nPositive:  AGR2, KRT18, OLFM4, GPX2, PIGR, PPP1R1B, SLC12A2, CEACAM5, TFF3, REG4 \n       LGALS4, FCGBP, CLCA1, SPINK1, MUC2, DMBT1, ST6GALNAC1, SPINK4, STARD10, CDC42EP5 \n       REG1A, KRT8, CREB3L1, ITLN1, BCAS1, MGST1, ADH1C, HEPACAM2, FOXA3, SPDEF \nNegative:  APOB, CYP3A4, SLC6A19, APOA4, ACE, SLC15A1, CUBN, APOC3, ALPI, APOA1 \n       CREB3L3, GUCA2A, XPNPEP2, MGAM, MTTP, C3orf85, DPEP1, PRAP1, ANPEP, CDHR2 \n       GUCA2B, SLC5A12, SLC26A3, SMIM24, SULT1A2, IL32, NAALADL1, CPO, MEP1B, MS4A10 \nPC_ 5 \nPositive:  PCLAF, MKI67, TOP2A, STMN1, UBE2C, HMGB2, BIRC5, NUSAP1, AURKB, RRM2 \n       TYMS, PTTG1, CDK1, CDKN3, CENPF, TK1, CCNA2, GTSE1, TPX2, CDC20 \n       TUBB, RGS13, CENPA, CKS2, MND1, HMMR, ASPM, MYBL2, H2AFZ, CDT1 \nNegative:  CLCA1, MUC2, FCGBP, REG4, BCAS1, TFF3, SPINK4, ZG16, HEPACAM2, REP15 \n       S100P, CEACAM5, ATOH1, MLPH, SPDEF, CREB3L1, TFF1, SCNN1A, ITLN1, FOXA3 \n       ST6GALNAC1, LRRC26, CEACAM6, STARD10, ZG16B, FXYD3, TPSG1, NPDC1, TSPAN1, AC005833.1 \n\n\nComputing nearest neighbor graph\n\n\nComputing SNN\n\n\nModularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n\nNumber of nodes: 10000\nNumber of edges: 433662\n\nRunning Louvain algorithm...\nMaximum modularity in 10 random starts: 0.9557\nNumber of communities: 21\nElapsed time: 0 seconds\n\n\nWarning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric\nTo use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation'\nThis message will be shown once per session\n\n\n15:03:27 UMAP embedding parameters a = 0.9922 b = 1.112\n\n\n15:03:27 Read 10000 rows and found 50 numeric columns\n\n\n15:03:27 Using Annoy for neighbor search, n_neighbors = 30\n\n\n15:03:27 Building Annoy index with metric = cosine, n_trees = 50\n\n\n0%   10   20   30   40   50   60   70   80   90   100%\n\n\n[----|----|----|----|----|----|----|----|----|----|\n\n\n**************************************************|\n15:03:27 Writing NN index file to temp file /var/folders/x6/85llj18n3j18wmy0ylhx6pdm0000gn/T//RtmpEx0dZs/filee68e549b53be\n15:03:27 Searching Annoy index using 1 thread, search_k = 3000\n15:03:29 Annoy recall = 100%\n15:03:29 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30\n15:03:30 Found 2 connected components, falling back to 'spca' initialization with init_sdev = 1\n15:03:30 Using 'irlba' for PCA\n15:03:30 PCA: 2 components explained 32.73% variance\n15:03:30 Scaling init to sdev = 1\n15:03:30 Commencing optimization for 500 epochs, with 438422 positive edges\n15:03:30 Using rng type: pcg\n15:03:37 Optimization finished\n\nDimPlot(obj, reduction = \"umap\")\n\n\n\n\n\n\n\n\n\nInspecting the clustering\nLarge experiments usually are done in batches and that can be a cofounder that we don’t want to include in our analysis. If there is a strong batch effect, cells from the same cell type will cluster together based on their batch and not on their true identity. A quick way to check if you have a strong batch effect in your data is to plot the UMAP above but colored (or split) by batch. (You can also do this with any other variable that you have in your metadata)\n\nDimPlot(obj, reduction = \"umap\", group.by = \"batch\")\n\n\n\n\n\n\n\n# If you want to try the split version, un-comment (delete the '#\") and run the line below\n# DimPlot(obj, reduction = \"umap\", split.by = \"batch\") + NoLegend()\n\n\n\nIdentifying the clusters\nSince we don’t see major batch effects, we can continue our analysis. Now, we want to identify the clusters. What cell types are they? To answer this question, we need to find the genes that define each cluster, or marker genes. These are genes that are differentially expressed in that cluster specifically when compared to all other cells. This is done using the code below. The function FindAllMarkers() performs a differential expression testing for each clusters versus all other cells, therefore, it might take a few minutes to run, depending on your computer’s specs. (You can skip this step if it takes too long or if your machine can’t handle it and go to to the cell identification step).\n\nmarker_genes &lt;- FindAllMarkers(obj, \n                               only.pos = TRUE, # return only the positive differentially expressed genes\n                               min.pct = 0.1, # only test genes that are detected in at least 10% of the cells in either cluster\n                               logfc.threshold = 0.25) # the logFC of a gene between the two groups has to be at least 0.25\n\nThis gives you a large table with all the results. To make it easier to look at the markers, let’s reshape this and display only the top 10 most significant marker genes for each cluster.\n\n# Getting the top 10 markers per cluster based on p-val and FC\ntop.markers &lt;- marker_genes %&gt;% \n  group_by(cluster) %&gt;%\n  filter(p_val_adj &lt; 0.05) %&gt;%\n  arrange(p_val_adj, by.group = TRUE) %&gt;%\n  top_n(n = 10, wt = avg_log2FC)\n\n# Reshaping the table\ntop.markers.clean &lt;- top.markers %&gt;%\n  dplyr::select(cluster, gene) %&gt;%\n  group_by(cluster) %&gt;%\n  summarise(markers = str_c(unlist(pick(gene)), collapse=', '))\n  \nknitr::kable(top.markers.clean)\n\n\n\n\n\n\n\n\ncluster\nmarkers\n\n\n\n\n0\nLINC00926, BANK1, FCER2, LINC02397, IGHD, GAPT, HVCN1, FAM129C, CD1C, TNFRSF13B\n\n\n1\nCCL5, KLRD1, TRGC2, CD160, GZMA, XCL1, XCL2, TRGC1, KLRC2, GZMK\n\n\n2\nAPOB, APOA4, APOC3, APOA1, SLC5A12, MEP1B, SLC13A1, SLC2A2, ENPP7, FADS6\n\n\n3\nTIGIT, CD40LG, LEF1, ICOS, CTLA4, CHRM3-AS2, TOX2, CD28, TBC1D4, TNFRSF4\n\n\n4\nLUM, ADAMDEC1, CCL11, CXCL6, HAPLN1, FNDC1, CCL8, CCL13, SFTA1P, OGN\n\n\n5\nRRM2, CDK1, CLSPN, MND1, GTSE1, CENPA, CDCA5, SPC25, DLGAP5, FDCSP\n\n\n6\nOLFM4, GPX2, PLA2G2A, LGR5, GP2, REG3A, ITLN2, PRSS2, DEFA6, DEFA5\n\n\n7\nIGHA2, JCHAIN, LINC02362, AL391056.1, ENAM, AMPD1, IGLL5, IGHA1, LINC00582, FAM92B\n\n\n8\nFPR3, LILRB2, CD209, FCN1, CD163, LILRB5, SIGLEC1, S100A12, CD300E, TLR8\n\n\n9\nRGS13, SERPINA9, SUGCT, BORCS8-MEF2B, HTR3A, WDR66, CAMP, HRK, LINC00877, MIR3681HG\n\n\n10\nMUC2, CLCA1, FCGBP, ZG16, REP15, TFF1, ATOH1, CAPN9, B3GNT6, SYTL5\n\n\n11\nPLVAP, MMRN2, SOX18, FAM110D, PALMD, SOX17, SELE, LCN6, FCN3, CADM3-AS1\n\n\n12\nHLA-DQA2, MTRNR2L1, LINC00926, BANK1, IGHD, LINC02397, GBP4, FCRL1, C12orf42, HAPLN3\n\n\n13\nIGHG2, IGHGP, IGHG3, IGHG4, IGHG1, IGLV3-1, IGLV6-57, JSRP1, IGKC, IGLC3\n\n\n14\nALKAL2, ENHO, POSTN, NPY, VEGFD, GLP2R, LY6H, VSTM2A, COL4A6, LINC01915\n\n\n15\nNOTCH3, COX4I2, HIGD1B, FAM162B, FOXS1, HEYL, FHL5, IL17B, AC018647.1, AVPR1A\n\n\n16\nACTG2, HHIP, SOSTDC1, HSD17B6, DES, MYOCD, SLC30A8, LUZP2, CCDC144NL-AS1, ALKAL1\n\n\n17\nNRXN1, CDH19, GFRA3, PCSK2, LRRTM1, SOX2, FOXD3, PTPRZ1, LINC01505, LINC00461\n\n\n18\nLYVE1, MMRN1, C6orf141, RELN, PLIN5, AC007998.3, LINC02308, STAB2, AC011498.4, GPR1\n\n\n19\nTPSAB1, CPA3, TPSB2, MS4A2, KRT1, HDC, ADCYAP1, TPSD1, AL662860.1, LINC00323\n\n\n20\nCRYBA2, SCGN, SCG2, MIR7-3HG, MARCH4, CDH22, AC005256.1, LCN15, PYY, NTS\n\n\n\n\n\nWith the table above and a reference gene markers list, or a very good knowledge of biology, or a lot of Googling, you can identify each cluster. Luckly for us, this dataset already has the cell type annotated in the metadata, so we will use that to help us. Let’s first see how the clusters are distributed in the original cell type annotation.\n\nggplot(obj@meta.data, aes(x = seurat_clusters, y = cell_type)) +\n  geom_count() +\n  theme_classic()\n\n\n\n\n\n\n\n\nAs mentioned above, we have way less clusters and they are not as good defined as in the original publication, because we are working with just a small part of it. So, we are adding the following simplified annotation based on the overlap seen in the plot above:\n\n\n\nSeurat cluster\nCell type\n\n\n\n\n0, 9, 12\nB cells\n\n\n1\nActivated T cells\n\n\n2\nEnterocytes\n\n\n3\nT cells\n\n\n4, 14, 15, 16, 18\nStromal cells\n\n\n5, 7, 13\nPlasma cells\n\n\n8\nMacrophages\n\n\n6\nStem and TA cells\n\n\n10\nGoblet cells\n\n\n19\nMast cells\n\n\n11\nEndothelial cells\n\n\n17\nGlia\n\n\n20\nEECs\n\n\n\nWe will add this new cell type annotation as a new column in the metadata called cell_type_new. Then, we can visualize the UMAP with this new annotation.\n\nobj@meta.data &lt;- obj@meta.data %&gt;%\n  mutate(cell_type_new = case_when(\n    seurat_clusters %in% c(0,9,12) == TRUE ~ \"B cells\",\n    seurat_clusters %in% c(1) == TRUE ~ \"Activated T cells\",\n    seurat_clusters %in% c(2) == TRUE ~ \"Enterocytes\",\n    seurat_clusters %in% c(3) == TRUE ~ \"T cells\",\n    seurat_clusters %in% c(4, 14, 15, 16, 18) == TRUE ~ \"Stromal cells\",\n    seurat_clusters %in% c(5, 7, 13) == TRUE ~ \"Plasma cells\",\n    seurat_clusters %in% c(8) == TRUE ~ \"Macrophages\",\n    seurat_clusters %in% c(6) == TRUE ~ \"Stem and TA cells\",\n    seurat_clusters %in% c(10) == TRUE ~ \"Goblet cells\",\n    seurat_clusters %in% c(19) == TRUE ~ \"Mast cells\",\n    seurat_clusters %in% c(11) == TRUE ~ \"Endothelial cells\",\n    seurat_clusters %in% c(17) == TRUE ~ \"Glia\",\n    seurat_clusters %in% c(20) == TRUE ~ \"EECs\"\n  ))\n\nDimPlot(obj, group.by = \"cell_type_new\", label = T) + NoLegend() # this puts the labels in the plot instead of a legend on the side\n\n\n\n\n\n\n\n\nNow that we have identified our cell types, we can perform some analysis.\n\n\n\n\n\n\nNote\n\n\n\nWhen you do your own analysis, you will have to actually identify the cell types yourself. To get help with that, check the “Cell type indentification” tutorial.",
    "crumbs": [
      "Single-cell RNA-seq data analysis"
    ]
  },
  {
    "objectID": "scRNA-seq.html#downstream-analyses",
    "href": "scRNA-seq.html#downstream-analyses",
    "title": "Single-cell RNA-seq data analysis",
    "section": "Downstream analyses",
    "text": "Downstream analyses\n\nDifferential expression analysis\nIn this dataset we have samples from individuals with Crohn’s Disease and healthy individuals, so we can investigate if there is a difference in gene expression of the cell types we identified because of an individual being sick. Let’s first just check if cells are present in both conditions by plotting the UMAP split by condition.\n\np &lt;- DimPlot(obj, group.by = \"cell_type_new\", split.by = \"Diagnosis\")\nprint(p)\n\n\n\n\n\n\n\n\nNow we can start the differential testing. We are using a method called MAST, that has been shown to perform well in single-cell data and allows us to correct for covariates such as batch, sex, age, and the cellular detection rate (the fraction of genes that are detected/expressed in each cell).\n\n# Choose the cell type for that you want to test for\ncluster &lt;- \"Enterocytes\"\nobj_test &lt;- subset(obj, subset = cell_type_new == cluster)\n\n# Set the dataset to test control vs disease\nIdents(obj_test) &lt;- \"Diagnosis\"\n\n# Calculating CDR (cellular detection rate) to add in the model and correct for it\nCDR &lt;- scale(colSums(GetAssayData(obj_test, assay = \"RNA\", layer = \"data\") &gt; 0))\nobj_test$CDR &lt;- CDR\n\n# Finding DEGs - note how CDR is included in the model via the latent.vars parameter\nDEG &lt;- FindMarkers(obj_test, ident.1 = 'Pediatric Crohn Disease', ident.2 = 'Pediatric healthy', test.use = 'MAST', logfc.threshold = 0,\n                       min.pct = 0.25, latent.vars = 'CDR')\n\n\nDone!\n\n\nCombining coefficients and standard errors\n\n\nCalculating log-fold changes\n\n\nCalculating likelihood ratio tests\n\n\nRefitting on reduced model...\n\n\n\nDone!\n\n# Create a dummy variable for gene names - it will be useful for plotting\nDEG$gene &lt;- rownames(DEG)\n\n# Add the classification if a gene is up or down regulated based on the defined cutoffs for log2FC and adjusted p-value\nDEG$DE &lt;- NA\n\nthreshold &lt;- 0.5 # cutff for logFC\n\nDEG &lt;- DEG %&gt;%\n  mutate(DE = case_when(\n    p_val_adj &lt; 0.05 & avg_log2FC &gt; threshold ~ 'upregulated',\n    p_val_adj &lt; 0.05 & avg_log2FC &lt; -threshold ~ 'downregulated',\n    p_val_adj &gt; 0.05 | abs(avg_log2FC) &lt; threshold ~ 'not DE'),\n    DE_gene = if_else(DE=='not significant', NA, gene)\n    )\n\n# Order and print the most upregulated genes\nDEG &lt;- DEG %&gt;%\n  arrange(desc(avg_log2FC)) # to see the most downregulated genes, just remove the desc()\n\nknitr::kable(head(DEG))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\np_val\navg_log2FC\npct.1\npct.2\np_val_adj\ngene\nDE\nDE_gene\n\n\n\n\nFOLH1\n0\n2.534950\n0.342\n0.090\n0e+00\nFOLH1\nupregulated\nFOLH1\n\n\nHRCT1\n0\n1.569167\n0.263\n0.165\n8e-07\nHRCT1\nupregulated\nHRCT1\n\n\nRARRES1\n0\n1.451417\n0.286\n0.209\n1e-06\nRARRES1\nupregulated\nRARRES1\n\n\nHLA-DPB1\n0\n1.422872\n0.603\n0.327\n0e+00\nHLA-DPB1\nupregulated\nHLA-DPB1\n\n\nMTRNR2L8\n0\n1.328422\n0.765\n0.590\n0e+00\nMTRNR2L8\nupregulated\nMTRNR2L8\n\n\nSLC52A1\n0\n1.284953\n0.367\n0.232\n2e-07\nSLC52A1\nupregulated\nSLC52A1\n\n\n\n\n\nWe can now visualize the DEG results as a volcano plot and highlight some of the genes using the code below.\n\ncolor_map &lt;- c(\"not DE\" = \"gray\", \"downregulated\" = \"#2166ac\", \"upregulated\" = \"#b2182b\")\n\nggplot(DEG, aes(x = avg_log2FC, y = -log10(p_val_adj), color = DE, label = gene)) +\n      geom_jitter() +\n      geom_text_repel(max.overlaps = 5, force = 30, show.legend = FALSE) + \n      geom_hline(yintercept = -log10(0.05), colour = '#696969', linetype = 'dashed') +\n      geom_vline(xintercept = -threshold, colour = '#696969', linetype = 'dashed') +\n      geom_vline(xintercept = threshold, colour = '#696969', linetype = 'dashed') +\n      scale_color_manual('', values = color_map) +\n      labs(title = \"DEGs in Enterocytes in Chron's Disease\") +\n      default_theme()\n\nWarning: ggrepel: 2296 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps\n\n\n\n\n\n\n\n\n\n\n\nPathway enrichment analysis\nThe next question we can ask is if the up or downregulated genes are involved in common functions, like we did in the bulk RNA-seq analysis. To keep it simple, we will do just a GSEA here, but during your analysis, feel free to try the other methods, the idea is the same.\n\n# Create the rannked gene list required for the function, this will be the DEGs ordered by log2FC\ngeneList_df &lt;- DEG %&gt;%\n  filter(DE != \"not significant\") %&gt;%\n  dplyr::select(gene, avg_log2FC, p_val_adj) %&gt;%\n  arrange(desc(avg_log2FC))\n\ngeneList &lt;- geneList_df$avg_log2FC\nnames(geneList) &lt;- geneList_df$gene\n  \ngsea &lt;- gseGO(\n  geneList = geneList,\n  OrgDb = org.Hs.eg.db,\n  ont = \"BP\", \n  keyType = \"SYMBOL\",\n  minGSSize = 10,\n  pvalueCutoff = 0.05\n)\n\nThis returns an object with the results that we can inspect with head(gsea@result). Although this table is good to inspect the results in detail, it is not a great way to visualize the results. For that, we can plot the most significant enriched and suppressed pathways. (In this case we only have significant suppressed pathways, so the plot will only have those, but you get the idea).\n\n# This gets the top 5 enriched and supressed pathways based on the Normalized Enrichment Score (NES)\ntmp &lt;- arrange(gsea, desc(abs(NES))) %&gt;%\n  group_by(sign(NES)) %&gt;%\n  slice(1:5)\n\n# Now we plot them\nggplot(tmp, showCategory = 10,\n       aes(NES, fct_reorder(Description,NES), fill = -log10(p.adjust))) +\n  geom_col() +\n  geom_vline(xintercept = 0, colour = '#696969', linetype = 'dashed') +\n  scale_fill_gradientn(colours=c(\"#b3eebe\", \"#46bac2\", \"#371ea3\"),\n                        guide=guide_colorbar(reverse=TRUE)) +\n  labs(x = 'Normalized Enrichment Score',\n      y = '') +\n  default_theme() +\n  theme(text = element_text(size = 11))",
    "crumbs": [
      "Single-cell RNA-seq data analysis"
    ]
  },
  {
    "objectID": "scRNA-seq.html#conclusion",
    "href": "scRNA-seq.html#conclusion",
    "title": "Single-cell RNA-seq data analysis",
    "section": "Conclusion",
    "text": "Conclusion\nThis covers the basics of pre-processing a single-cell RNA-seq dataset and doing some downstream analysis to answer biological questions. Feel free to play with this code and try some different clustering parameter, use different cell types for the differential testing, etc. When you feel ready, run your own analysis with the assignment dataset.",
    "crumbs": [
      "Single-cell RNA-seq data analysis"
    ]
  },
  {
    "objectID": "cell-identification.html",
    "href": "cell-identification.html",
    "title": "Cell type identification",
    "section": "",
    "text": "As you have seen already, what you get from single-cell RNA-seq is a matrix with RNA counts per cell with no information about what cell type they are. It’s up to us to find that out. The two most common ways are 1) look at the expression of known marker genes, or 2) compare with a well-annotated reference. In this tutorial you will learn how to do the option 2 with a tool called CellTypist. This tool is based in Python, but don’t worry you don’t need to install anything. We can run this using Google Colab in your RUG account (more details on how to do that below).",
    "crumbs": [
      "Cell type identification"
    ]
  },
  {
    "objectID": "cell-identification.html#introduction",
    "href": "cell-identification.html#introduction",
    "title": "Cell type identification",
    "section": "",
    "text": "As you have seen already, what you get from single-cell RNA-seq is a matrix with RNA counts per cell with no information about what cell type they are. It’s up to us to find that out. The two most common ways are 1) look at the expression of known marker genes, or 2) compare with a well-annotated reference. In this tutorial you will learn how to do the option 2 with a tool called CellTypist. This tool is based in Python, but don’t worry you don’t need to install anything. We can run this using Google Colab in your RUG account (more details on how to do that below).",
    "crumbs": [
      "Cell type identification"
    ]
  },
  {
    "objectID": "cell-identification.html#initial-set-up",
    "href": "cell-identification.html#initial-set-up",
    "title": "Cell type identification",
    "section": "Initial set-up",
    "text": "Initial set-up\nBefore we start, we need to export our dataset from a Seurat object in R to a AnnData object in Python. You should do this after running the “Pre-processing” steps, when you have your Seurat clusters ready. To convert your dataset to AnnData first you need to define a function in R that will save the files we need to create the object in Python.\n\nSeuratToAnndata &lt;- function(seurat_obj, name, path, assay = 'RNA', simple = FALSE) {\n  \n  if(simple == TRUE) {\n    write.csv(seurat_obj@meta.data, file=paste0(path, name, '_metadata.csv'), quote=F, row.names=F)\n  } else {\n    seurat_obj$barcode &lt;- colnames(seurat_obj)\n    seurat_obj$UMAP_1 &lt;- seurat_obj@reductions$umap@cell.embeddings[,1]\n    seurat_obj$UMAP_2 &lt;- seurat_obj@reductions$umap@cell.embeddings[,2]\n    write.csv(seurat_obj@meta.data, file=paste0(path, name, '_metadata.csv'), quote=F, row.names=F)\n    \n    # write dimensionality reduction matrix, PCA or harmony\n    write.csv(seurat_obj@reductions$harmony@cell.embeddings, file=paste0(path, name, '_pca_harmony.csv'), quote=F, row.names=F)\n  }\n  \n  # write expression counts matrix\n  require(Matrix)\n  if(assay == 'RNA') {\n    counts_matrix &lt;- GetAssayData(seurat_obj, assay='RNA', layer='counts')\n    writeMM(counts_matrix, file=paste0(path, name, '_RNA_counts.mtx'))\n  }\n  \n  if(assay == 'SCT') {\n    counts_matrix &lt;- GetAssayData(seurat_obj, assay='SCT', layer='data')\n    writeMM(counts_matrix, file=paste0(path, name, '_SCT_logcounts.mtx'))\n  }\n  \n  # write gene names\n  write.table(\n    data.frame('gene'=rownames(counts_matrix)) ,file=paste0(path, name, '_gene_names.csv'),\n    quote=F,row.names=F,col.names=F\n  )\n  \n}\n\nHere is an example of how you should use this function in R.\n\nobj &lt;- readRDS('data/SeuratObj_PreProcessed.rds')\nSeuratToAnndata(seurat_obj = obj,\n                name = 'My_Data', # choose the name of your file\n                path = 'data/', # the path where the files will be saved\n                assay = 'RNA', # saves the RNA information\n                simple = TRUE # doesn't save the PCA and UMAP information\n)\n\nAfter running this, you should have three new files in the data folder: My_Data_RNA_counts.mtx, My_Data_metadata.csv and My_Data_gene_names.csv. You will need to upload these files to your RUG Google Drive, where we will run the Python script using Colab.",
    "crumbs": [
      "Cell type identification"
    ]
  },
  {
    "objectID": "cell-identification.html#using-google-colab",
    "href": "cell-identification.html#using-google-colab",
    "title": "Cell type identification",
    "section": "Using Google Colab",
    "text": "Using Google Colab\nLog into your Google Drive Account, create a folder to save your data and upload the three files created above in that folder. Now click here to open the Colab Notebook, go to File &gt; Save a copy in Drive. This will create a copy of the script in your own Drive, that you can edit and run. Follow the instructions in the Colab notebook to finish the creation of your AnnData object.",
    "crumbs": [
      "Cell type identification"
    ]
  },
  {
    "objectID": "cell-identification.html#identifying-cell-types-with-celltypist",
    "href": "cell-identification.html#identifying-cell-types-with-celltypist",
    "title": "Cell type identification",
    "section": "Identifying cell types with CellTypist",
    "text": "Identifying cell types with CellTypist\nClick here to acesss the Colab notebook with the instructions on how to use CellTypist. Like before, just go to File &gt; Save a copy in Drive to copy the notebook to your Drive and make changes to the script.",
    "crumbs": [
      "Cell type identification"
    ]
  },
  {
    "objectID": "cell-identification.html#adding-the-cell-type-annotation-to-your-seurat-object",
    "href": "cell-identification.html#adding-the-cell-type-annotation-to-your-seurat-object",
    "title": "Cell type identification",
    "section": "Adding the cell type annotation to your Seurat object",
    "text": "Adding the cell type annotation to your Seurat object\nAfter completing the cell type classification with CellTypist, you should know which seurat clusters correspond to which cell types. You can now go back to R and add the cell type annotation like we did in the single-cell tutorial.",
    "crumbs": [
      "Cell type identification"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Welcome",
    "section": "",
    "text": "Hello! In this webpage, you will find the information and tutorials you need to analyse your own RNA-sequencing data that you generated in the lab. We will walk you through the basic steps in the analysis of bulk RNA-sequencing data and single-cell RNA sequencing data. Before we get started, follow the instructions below to set everything up.\n\nInstall or update R and RStudio\nIf you don’t have R and/or RStudio installed in your computer yet, download and install it following the instructions here. If you alredy have them installed, check if you need to update them (you can do this by opening RStudio and go to Help &gt; Check for Updates and then install it if necessary). To ensure compability with the tutorials and codes you will use during the course, make sure to have installed R version 4.4.1 or higher.\n\n\nInstall packages\nThe lines of code below will install the packages we will need during the analysis. Just copy them, paste into RStudio and execute.\n\nif (!require(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\")\nBiocManager::install(version = \"3.20\")\n\ninstall.packages(c('dplyr', 'tidyr', 'ggplot2', 'knitr', 'stringr', 'patchwork', 'viridis', 'ggrepel', 'corrplot', 'purrr', 'pheatmap', 'RColorBrewer', 'reshape2', 'forcats', 'Seurat'))\nBiocManager::install(c('DESeq2', 'edgeR', 'clusterProfiler', 'org.Hs.eg.db', 'ReactomePA', 'variancePartition', 'biomaRt', 'enrichplot', 'MAST'))\n\ninstall.packages(\"devtools\")\ndevtools::install_github(\"immunogenomics/presto\")\n\n\n\n\n\n\n\nWarning\n\n\n\nIf you are using Windows and this is your first time using R, you might get an error saying you need to install rtools. If that happens, try following the instructions here.\n\n\n\n\nDownload tutorial datasets\nCreate a folder in your computer where you are going to save the data, scripts and results of your analysis. Inside of this folder create a folder called “data”, download the file by clicking on the link below, and save the files in the “data” folder.\n\n\n\n\n\n\nImportant\n\n\n\nYou need to be logged in your RUG account to download the files.\n\n\nRequest download"
  },
  {
    "objectID": "Bulk_RNAseq_Tutorial.html",
    "href": "Bulk_RNAseq_Tutorial.html",
    "title": "Bulk RNA-seq data analysis",
    "section": "",
    "text": "This tutorial is build on data from duodenal biopsies of active celiac disease, treated celiac disease, and control individuals, as described by Aarón Ramírez-Sánchez et al. (2024). Here you will learn the basics on how to import RNA-seq data, explore the data, build contrasts, perform differential expression analysis, and gene set enrichment analysis.",
    "crumbs": [
      "Bulk RNA-seq data analysis"
    ]
  },
  {
    "objectID": "Bulk_RNAseq_Tutorial.html#introduction",
    "href": "Bulk_RNAseq_Tutorial.html#introduction",
    "title": "Bulk RNA-seq data analysis",
    "section": "",
    "text": "This tutorial is build on data from duodenal biopsies of active celiac disease, treated celiac disease, and control individuals, as described by Aarón Ramírez-Sánchez et al. (2024). Here you will learn the basics on how to import RNA-seq data, explore the data, build contrasts, perform differential expression analysis, and gene set enrichment analysis.",
    "crumbs": [
      "Bulk RNA-seq data analysis"
    ]
  },
  {
    "objectID": "Bulk_RNAseq_Tutorial.html#initial-set-up",
    "href": "Bulk_RNAseq_Tutorial.html#initial-set-up",
    "title": "Bulk RNA-seq data analysis",
    "section": "Initial set-up",
    "text": "Initial set-up\n\nSet working directory\nIn this step, you set your working directory, that is, the folder in your computer where you are going to save your scripts, data and results.\n\npath &lt;- '/Users/nvribeiro/Library/CloudStorage/OneDrive-UMCG/Desktop/PhD/Others/BMS-BigData-Course-2025' # you need to change this to your own path\n\nsetwd(path)\n\n\n\nLoad libraries\nIf you haven’t done, check the file “Preparation for data analysis – Big Data Course BMS 2025” and follow the instructions to install/update R, RStudio and the packages that you will used in the analysis. Then load the libraries.\n\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(knitr)\nlibrary(stringr)\nlibrary(patchwork)\nlibrary(edgeR)\nlibrary(clusterProfiler)\nlibrary(enrichplot)\nlibrary(org.Hs.eg.db)\nlibrary(ReactomePA)\nlibrary(viridis)\nlibrary(ggrepel)\nlibrary(purrr)\nlibrary(biomaRt)\nlibrary(pheatmap)\nlibrary(RColorBrewer)\nlibrary(reshape2)\nlibrary(variancePartition)\nlibrary(forcats)\n\n\n# Optional: define a default theme to be used in all plots\ndefault_theme &lt;- function(){\n  theme_bw() +\n    theme(panel.grid = element_blank(),\n          panel.border = element_rect(linewidth = 1),\n          axis.title = element_text(size = rel(1)),\n          axis.title.y.left = element_text(margin = margin(r = 10, unit = 'pt')),\n          axis.title.y.right = element_text(margin = margin(l = 10, unit = 'pt')),\n          axis.title.x.bottom = element_text(margin = margin(t = 10, unit = 'pt')),\n          plot.title = element_text(size = rel(1), hjust = 0.5, face = 'bold'),\n          axis.text = element_text(size = rel(1)),\n          axis.ticks.length = unit(5, 'pt'),\n          strip.background = element_rect(fill = \"#f5a9a9\", linewidth = 0),\n          strip.text = element_text(size = rel(1), color = \"black\")\n    )\n}\n\n\n\nLoad the dataset\nNow we load the dataset that you have previously downloaded and saved in your “data” folder. This file contains the reads mapped to the gene annotation and thus contains the raw data with which we will work.\n\ncounts &lt;- read.table(\"data/RNA_matrix.table\", header=TRUE)\nknitr::kable(head(counts))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCON1\nCON2\nCON3\nCON4\nCON5\nCON6\nCON7\nCON8\nCON9\nCON10\nCON11\nCON12\nCON13\nCON14\nCON15\nCON16\nCON17\nCON18\nCON19\nCON20\nCON21\nCON22\nCON23\nCON24\nCON25\nTCD1\nUCD1\nTCD2\nTCD3\nTCD4\nTCD5\nTCD6\nTCD7\nTCD8\nTCD9\nTCD10\nTCD11\nTCD12\nTCD13\nTCD14\nTCD15\nTCD16\nTCD17\nUCD2\nUCD3\nTCD18\nTCD19\nTCD20\nUCD4\nTCD21\nUCD5\nUCD6\nTCD22\nTCD23\nTCD24\nTCD25\nUCD7\nUCD8\nUCD9\nUCD10\nUCD11\nUCD12\nUCD13\nUCD14\nUCD15\nUCD16\nTCD26\nTCD27\nUCD17\nUCD18\nUCD19\nTCD28\nUCD20\nUCD21\nUCD22\nUCD23\nUCD24\nUCD25\nUCD26\nUCD27\nUCD28\nUCD29\n\n\n\n\nENSG00000000003\n306\n219\n280\n337\n528\n436\n334\n453\n483\n181\n407\n291\n392\n254\n400\n161\n406\n239\n215\n356\n340\n292\n645\n309\n385\n530\n887\n356\n62\n454\n375\n451\n285\n506\n337\n380\n289\n195\n468\n131\n383\n601\n161\n218\n333\n273\n505\n377\n405\n454\n372\n374\n281\n353\n354\n713\n474\n583\n438\n319\n388\n493\n280\n862\n471\n373\n316\n457\n480\n883\n674\n274\n519\n571\n398\n673\n523\n579\n950\n439\n776\n677\n\n\nENSG00000000005\n0\n0\n0\n0\n0\n0\n8\n0\n0\n1\n0\n0\n0\n0\n0\n0\n2\n0\n0\n2\n3\n2\n0\n0\n6\n0\n13\n0\n0\n0\n0\n0\n0\n0\n8\n0\n0\n0\n0\n0\n0\n10\n0\n0\n11\n0\n0\n0\n7\n6\n0\n0\n0\n0\n0\n0\n0\n15\n5\n1\n33\n0\n0\n0\n0\n0\n0\n1\n2\n44\n2\n0\n4\n2\n19\n0\n3\n0\n41\n54\n22\n10\n\n\nENSG00000000419\n462\n586\n240\n525\n760\n367\n411\n633\n620\n359\n363\n377\n395\n751\n551\n336\n495\n425\n687\n402\n462\n486\n269\n486\n518\n710\n928\n384\n757\n435\n326\n731\n556\n489\n537\n282\n685\n187\n496\n302\n500\n658\n474\n334\n365\n321\n518\n460\n540\n569\n166\n704\n376\n414\n519\n578\n854\n924\n789\n637\n634\n687\n326\n717\n431\n357\n275\n238\n493\n758\n580\n618\n574\n549\n475\n465\n398\n516\n1155\n775\n666\n516\n\n\nENSG00000000457\n327\n318\n374\n473\n429\n305\n409\n243\n248\n268\n283\n237\n279\n223\n170\n310\n354\n309\n200\n305\n237\n361\n187\n298\n431\n369\n355\n375\n261\n286\n142\n529\n196\n438\n424\n210\n322\n121\n351\n243\n226\n302\n256\n244\n185\n149\n364\n312\n260\n367\n471\n70\n377\n274\n181\n551\n467\n314\n322\n311\n348\n258\n147\n439\n368\n192\n260\n188\n276\n375\n297\n220\n223\n235\n177\n295\n235\n471\n530\n210\n235\n304\n\n\nENSG00000000460\n58\n41\n125\n134\n21\n69\n33\n34\n22\n33\n21\n45\n40\n83\n41\n33\n65\n59\n105\n61\n53\n65\n68\n54\n38\n76\n232\n120\n203\n100\n179\n71\n86\n37\n76\n33\n43\n33\n63\n52\n101\n70\n10\n35\n53\n21\n7\n41\n93\n64\n8\n150\n111\n52\n55\n51\n119\n169\n184\n61\n239\n65\n61\n119\n76\n57\n49\n40\n95\n114\n78\n6\n99\n81\n56\n52\n110\n109\n145\n21\n119\n37\n\n\nENSG00000000938\n827\n466\n491\n281\n458\n320\n467\n1111\n182\n367\n375\n391\n319\n748\n454\n629\n198\n315\n448\n371\n237\n326\n225\n372\n511\n426\n33\n375\n119\n66\n304\n345\n516\n302\n503\n262\n522\n194\n226\n384\n165\n114\n651\n823\n272\n137\n95\n173\n131\n489\n33\n299\n524\n192\n151\n796\n461\n465\n101\n275\n494\n261\n278\n199\n438\n130\n74\n268\n438\n71\n144\n366\n221\n180\n138\n90\n172\n608\n394\n355\n57\n86\n\n\n\n\n\nWe now have a dataframe where each row is a gene and each column is sample.\n\n\nPreparing the metadata\nDifferential expression analysis is the comparison of gene expression between one or more conditions while correcting for unwanted sources of variation. This information is usually stored in a metadata file, where you have many details about each sample such as condition, sex, age, etc. Here we load the metadata for this dataset.\n\nmetadata &lt;- read.csv('data/metadata_oslo_biopsies.csv', header=TRUE)\nrownames(metadata) &lt;- metadata$sample\n\n# Visualize the first rows\nknitr::kable(head(metadata))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsample\ncondition\nmarsh.score\nsex\nage\nH..pylori\nPPI\ncell.counts\nbatch.of.RNA.isolation\nbatch.of.sequencing\nRNA.concentration\nRIN.score\ntotal.reads\nGC.content\ncrypt.ratio..APOA4.KI67.\ngroup\n\n\n\n\nCON1\nCON1\nCTRL\nn.m.\nM\n37\nNA\nYes\n1500000\n2\nA\n2.28\n7.3\n2402861\n47.5\n1.487207\nMild inflammation\n\n\nCON2\nCON2\nCTRL\nn.m.\nM\n26\nNA\nYes\n1500000\n5\nA\n8.00\n7.9\n2644867\n46.0\n1.666809\nNon-inflamed\n\n\nCON3\nCON3\nCTRL\nn.m.\nF\n27\nNA\nNo\n1267000\n5\nA\n4.09\n8.1\n2548105\n47.0\n1.492771\nMild inflammation\n\n\nCON4\nCON4\nCTRL\nn.m.\nF\n38\nNA\nYes\n1620000\n4\nA\n5.81\n7.7\n2812289\n47.0\n1.697659\nNon-inflamed\n\n\nCON5\nCON5\nCTRL\nn.m.\nM\n86\nNA\nYes\n1800000\n3\nA\n12.28\n8.2\n2843597\n46.0\n1.631452\nNon-inflamed\n\n\nCON6\nCON6\nCTRL\nn.m.\nM\n65\nNA\nNo\n1800000\n3\nA\n4.13\n9.0\n1730893\n46.0\n1.447205\nMild inflammation\n\n\n\n\n# Make sure that the colnames of your count table are matching with the row names of your colData\n# Both of the comparisons below need to return TRUE\nall(rownames(metadata) %in% colnames(counts)) # check if all samples in the metadata are present in the counts\n\n[1] TRUE\n\nall(rownames(metadata) == colnames(counts)) # check if they are in the same order\n\n[1] FALSE\n\n# In this case all samples are in counts and metadata, but they are not in the same order.\n# To put them in the same order we run\ncounts &lt;- counts[, rownames(metadata)]\nall(rownames(metadata) == colnames(counts)) # now this is TRUE\n\n[1] TRUE",
    "crumbs": [
      "Bulk RNA-seq data analysis"
    ]
  },
  {
    "objectID": "Bulk_RNAseq_Tutorial.html#quality-control-and-exploratory-analysis",
    "href": "Bulk_RNAseq_Tutorial.html#quality-control-and-exploratory-analysis",
    "title": "Bulk RNA-seq data analysis",
    "section": "Quality control and exploratory analysis",
    "text": "Quality control and exploratory analysis\nNow we are going to create the edgeR object that will contain all the information about our experiment. We need to give the counts table, the matching metadata and a optional grouping factor (which we are not using in this case).\n\ny &lt;- DGEList(counts = counts,\n            samples = metadata,\n            genes = rownames(counts))\n\n\nRemove poorly expressed genes\nAs we sequenced this data set very deeply, a lot of noise is also captured, which is most prevalent in lowly expressed genes. To reduce the size of our data set and to make the differential expression analysis more robust by including only well-expressed genes that are more likely to be biologically informative, we will remove poorly expressed genes.\nFirst we visualize the counts in a histogram, this will give us an overview of the expression and we can try to decide a cutoff based on this graph. Here we are plotting the distribution of counts as log10 count-per-million (CPM).\n\n# Histogram of log(CPM)\ncpm &lt;- cpm(y, log = TRUE)\nhist(cpm)\n\n# With the following lines we add arbitrary cut-offs to histogram\n# Cutoff of 10\nabline(v = log10(10), col = \"blue\",lwd = 2)\n# cutoff of 100\nabline(v = log10(100), col = \"purple\",lwd = 2)\n# cutoff of 500\nabline(v = log10(500), col = \"red\",lwd = 2)\n# cutoff of 1000\nabline(v = log10(1000), col = \"orange\",lwd = 2)\n\n\n\n\n\n\n\n\nYou will notice a bi-modal distribution, in which a large chunk of genes is barely expressed, and a smaller chuck is expressed much more. We see that the bump with highly expressed genes occurs after the purple line (100 counts), so we can use that as a cut-off or, if you want to focus only on the really highly expressed genes, 500 or 1000 counts. Here I chose 500.\nThe function we will use to filter, filterByExpr, allows us to specify some parameters as the minimum counts required, if you want to filter per group, or use a formula.\n\nkeep &lt;- filterByExpr(y,\n                    group = y$samples$condition, # considers the group when filtering - optional\n                    min.count = 500) # the number you decided based on the histogram above\n\ny_filtered &lt;- y[keep, , keep.lib.sizes=FALSE]\n\nprint(paste0(\"Number of genes before filtering: \", dim(y)[1]))\n\n[1] \"Number of genes before filtering: 53042\"\n\nprint(paste0(\"Number of genes after filtering: \", dim(y_filtered)[1]))\n\n[1] \"Number of genes after filtering: 6809\"\n\n\nWe now reduced our dataset from 53,042 genes to 6,809. This will help speed up the calculations and only focus on genes that are expressed at high levels and probably more biologically relevant.\n\n\nPrincipal component analysis (PCA)\nThe PCA can help assess which samples are more closely related to each other, and how much variation is found between samples. We can also use PCA to check if other variables in our metadata are unwanted sources of variation that should be included in the model. To calculate the PCA, we use the logCPM counts.\n\n\n\n\n\n\nTip\n\n\n\nIf you are not familiar with PCA, watch this video: https://www.youtube.com/watch?v=HMOI_lkzW08\n\n\n\n# First define a function to make easier to plot the PCs. This function makes a PCA plot for the any PCs specified in \"coord_1\" and \"coord_2\" and will group the points (color) by a metadata column specified in \"color_by\". \"coldata\" is your metadata (stored in the \"samples\" part of the edgeR object)\nplotPC &lt;- function(pca_obj, coldata, coord_1, coord_2, color_by) {\n\n  var_explained &lt;- pca$sdev^2 / sum(pca$sdev^2)\n  var_explained_df &lt;- tibble(PC = paste0('PC', seq_along(var_explained)),\n                             Var_Explained = var_explained)\n  \n  df &lt;- as.data.frame(cbind(coldata, pca$x))\n  \n  x_label &lt;- paste0(coord_1, ' (', round(var_explained_df$Var_Explained[var_explained_df$PC == coord_1]*100, digits = 2), '%)')\n  y_label &lt;- paste0(coord_2, ' (', round(var_explained_df$Var_Explained[var_explained_df$PC == coord_2]*100, digits = 2), '%)')\n  \n  p &lt;- ggplot(df, aes(x = !!sym(coord_1), y = !!sym(coord_2), color = as.factor(!!sym(color_by)))) +\n    geom_point(size = 3) +\n    scale_color_viridis_d() +\n    labs(x = x_label, y = y_label) +\n    default_theme()\n  \n  return(p)\n  \n}\n\n# The next function we define is to create a scree plot\n# Makes a Scree plot based on the PCA results, if n_pcs = NULL, plots all available PCs\nplotScree &lt;- function(pca, n_pcs = NULL){\n  \n  if (is.null(n_pcs)){\n    n_pcs &lt;- ncol(pca$x)\n  }\n  \n  # Extract variance explained\n  var_explained &lt;- pca$sdev^2 / sum(pca$sdev^2)\n  cumulative_var &lt;- cumsum(var_explained)\n  \n  # Create a data frame for plotting\n  plot_data &lt;- data.frame(\n    PC = seq_along(var_explained),\n    Variance_Explained = var_explained,\n    Cumulative_Explained = cumulative_var\n  )\n  \n  plot_data &lt;- plot_data[1:n_pcs,]\n  \n  # Plot\n  ggplot(plot_data, aes(x = factor(PC))) +\n    geom_bar(aes(y = Variance_Explained), stat = \"identity\", fill = \"#22A884FF\") +\n    geom_line(aes(y = Cumulative_Explained, group = 1), color = \"#2A788EFF\", linewidth = 1) +\n    geom_point(aes(y = Cumulative_Explained), color = \"#2A788EFF\", size = 2) +\n    scale_y_continuous(\n      name = \"Fraction of Variance Explained\",\n      sec.axis = sec_axis(~., name = \"Cumulative Explained Variance\"),\n      expand = c(0,0)\n    ) +\n    labs(\n      title = \"Scree Plot\",\n      x = \"Principal Component\",\n      y = \"Fraction of Variance\"\n    ) +\n    default_theme()\n  \n}\n\n# Now calculate the PCs and plot\ncpm &lt;- cpm(y_filtered, log = TRUE)\npca &lt;- prcomp(t(cpm), scale. = TRUE)\n\nFirst we can see how much variation is explained by the PCs using a scree plot. For example, we can see that the first 3 PCs already explain almost 60% of the variance, and after each PCs doesn’t add too much to the variance. That means that if we see a variable having an effect in the first 3 PCs, it is probably a good idea to correct for that during the testing.\n\nplotScree(pca, n_pcs = 20)\n\n\n\n\n\n\n\n\nHere you can see that the samples from controls (CTRL) and treated celiac disease (TCD) tend to cluster together and separated from the untreated celiac disease (UCD).\n\n# Plot the first 2 PCs colored by the condition\nplotPC(pca,\n      coldata = y_filtered$samples,\n      coord_1 = 'PC1',\n      coord_2 = 'PC2',\n      color_by = 'condition')\n\n\n\n\n\n\n\n\nHere you can see that the samples from controls (CTRL) and treated celiac disease (TCD) tend to cluster together and separated from the untreated celiac disease (UCD). You can plot any other PCs and grouping variable you want to explore how that variable influences the data, for example, batch of sequencing that seems to be a significant source of variation:\n\nplotPC(pca,\n      coldata = y_filtered$samples,\n      coord_1 = 'PC1',\n      coord_2 = 'PC2',\n      color_by = 'batch.of.sequencing')\n\n\n\n\n\n\n\n\n\n\nNormalization of read counts\nIn order to properly perform certain downstream analysis, such as principal component analysis (PCA), or clustering, we need to properly normalize the counts. This step adjusts the raw counts to account for technical variations that can mask true biological differences. These factors are things like sequencing depth, library sizes, gene length, and GC content. In edgeR, we normalize the counts using the trimmed mean M-values (TMM) method with the function normLibSizes\n\ny_filtered &lt;- calcNormFactors(y_filtered)\n\n\n\nVariance partition analysis (optional)\nAlternatively to the PCA, you can use a “Variance Partition analysis” to quantify and interpret the sources of biological and technical variation in your data. This uses the package variancePartition. This uses the TMM normalized counts and a formula with the variables from your metadata you want to check (more on models and formulas will be explained in future steps). You can investigate any variables you want at once here, instead of one by one as you would do in the PCA.\n\n# First we assess correlation between all pairs of variables\nform &lt;- ~ condition + sex + age + batch.of.RNA.isolation + batch.of.sequencing + RNA.concentration + RIN.score + lib.size + cell.counts + H..pylori + marsh.score\nC &lt;- canCorPairs(form, y_filtered$samples)\n\nWarning in canCorPairs(form, y_filtered$samples): Regression model may be problematic.\nHigh colinearity between variables:\n  condition and marsh.score\n\nplotCorrMatrix(C)\n\n\n\n\n\n\n\n\nWe see from this plot that GC content, RIN score, batch of isolation and batch of sequencing are all strongly correlated, so we don’t want to include all of them in our model. Because batch of sequencing was also important in the PCA, let’s use just that one.\nNow we are going to fit a model in the gene expression data to check how much each variable contributes to the variation, you can choose which variables to include based on the previous plot.\n\ndesign &lt;- model.matrix(~condition, y_filtered$samples)\nv &lt;- voom(y_filtered, design)\n\n# We need to scale some variables so they are all in the same scale and comparable\ny_filtered$samples$age &lt;- scale(y_filtered$samples$age)\ny_filtered$samples$lib.size_scaled &lt;- scale(y_filtered$samples$lib.size)\ny_filtered$samples$cell.counts_scaled &lt;- scale(y_filtered$samples$cell.counts)\n\n# Categorical variables need to be specified with (1|variable)\nform &lt;- ~ (1|condition) + (1|sex) + (1|batch.of.sequencing) + (1|H..pylori) + (1|marsh.score) + age + RNA.concentration + lib.size_scaled + cell.counts_scaled\nvarPart &lt;- fitExtractVarPartModel(v, form, y_filtered$samples)\n\nWarning: \nVariables contain NA's: H..pylori, age \nSamples with missing data will be dropped.\n\n\nWarning in .fitExtractVarPartModel(exprObj, formula, data, REML = REML, : Model failed for 2 responses.\n  See errors with attr(., 'errors')\n\nplotVarPart(varPart)\n\n\n\n\n\n\n\n\nIn this plot, we can see how much each variable contributes to the variance in the data (the model is fit for every gene, that’s why you see a distribution). Quite some variance is explained by condition (and therefore also Marsh score, a measure of inflammation in CeD), as you would expect. Batch of sequencing, sex, age, and RNA concentration are all also some significant sources of variation that we could include in the model. However, we see that there is still a lot of variance left in the residuals - that means variance that is not being captured by any of the other variables in the model. This can happen for many reasons that we won’t go into details here, but keep in mind that ideally you want a model where most of variance is explained by the variables in the model and you don’t have much left in the residuals.",
    "crumbs": [
      "Bulk RNA-seq data analysis"
    ]
  },
  {
    "objectID": "Bulk_RNAseq_Tutorial.html#differential-expression-analysis",
    "href": "Bulk_RNAseq_Tutorial.html#differential-expression-analysis",
    "title": "Bulk RNA-seq data analysis",
    "section": "Differential expression analysis",
    "text": "Differential expression analysis\nThe definition of a differential expressed gene (DEG) usually depends on whether or not a particular gene is significantly (p-value = 0.05, after multiple testing correction) over or under expressed when compared to another class (can be different treatment, control, tissue etc,). Nevertheless, we can be a bit more strict in this definition, we could require either a lower p-value (such as 0.01, or 0.001), and require a certain difference of expression between the two conditions, this difference between two conditions can be interpreted as the log2 fold change: \\(log2FC = log2 (mean expression condition 1 /mean expression condition 2)\\)\nNow that we have looked at the data and seen what things may affect the expression of genes in there, we can start making a design matrix to do differential expression analysis. A design matrix is a table that represents your experimental setup in a mathematical form. It tells a statistical model which samples belong to which experimental groups, such as “diseased” vs. “healthy” and also how other variables (such as sex, age, etc.) affect the sample. For a more detailed explanation on how to design matrices for many types of experimental designs, check this guide.\n\nBuilding a design matrix\nThe first thing in you want to include in your design is of course the variable you are more interested on, for example here we want to find the genes that are differentially expressed because of condition . Next, you want to include your covariates: the variables that we identified above that influence the data but are not the object of our investigation, so we correct for them. You can write the formula for the design matrix in two ways - with or without intercept - and to do that we use the function model.matrix and a formula, which always starts with a ~ followed by your variables, for example ~ condition + sex + age.\n\nModel with intercept\nLet’s use a simple example where we are modeling the effect of group (disease or control), the design matrix can be created with model.matrix(~group). This creates a model with intercept. The intercept is the reference level for group, in this case, “control”. In this case, gene expression is modeled as Y ~ a + Xb, where Y is the expression, a is the intercept, X is 0 (control) or 1 (disease), and b represents how much the expression changes from the reference group. . When X = 0, Y = a, the expression for control. When X = 1, Y = a + b, the expression for disease. Below is a visual representation of how to interpret this.\n\n\n\nModel without intercept\nA design matrix without intercept is coded as model.matrix(~0+group). This model is essentially the same as before, however now you have a term associated with group control and a term associated with group disease: Y ~ aX1 + bX2, where X1 is 1 for control and 0 for disease and X2 is 1 for disease and 0 for control.\n\nThe result you get from both models is the same, but for experimental designs with more than 2 groups (like our data) and other complex designs, is easier to work with the model without intercept. That is because having one term for each group allows you to easily define the contrasts for exactly what you want to test and find the DEGs for.\n\n\n\nDefining a contrast matrix\nNow that we have a model for the gene expression, we want to find the difference between the mean expression of the groups of interest. The difference in parameter estimates can be calculated using a contrast matrix via the makeContrast function. To specify your comparison of interest, use the columns from the design matrix, for example:\n## DO NOT RUN ##\ndesign &lt;- model.matrix(0+group)\nmakeContrasts(groupSICK - groupHEALTHY, levels = colnames(design))\nThis will create the contrast to find the DEGs in sick vs healthy that we will use in the following steps. Note that this is only applicable when creating a design matrix without intercept. Back to our data, this is how we will define our design matrix and contrasts, including the covariates:\n\n# Here it is also important that the categorial variables are factors and the numerical variables are on the same scale\ny_filtered$samples$condition &lt;- factor(y_filtered$samples$condition, levels = c('CTRL', 'TCD', 'UCD'))\ny_filtered$samples$batch.of.sequencing &lt;- factor(y_filtered$samples$batch.of.sequencing)\ny_filtered$samples$sex &lt;- factor(y_filtered$samples$sex)\ny_filtered$samples$RNA.concentration &lt;- scale(y_filtered$samples$RNA.concentration)\n\n# The parameter data in model.matrix() is your metadata (y$samples)\ndesign &lt;- model.matrix(~ 0 + condition + batch.of.sequencing + sex + RNA.concentration, data = y_filtered$samples)\nhead(design)\n\n     conditionCTRL conditionTCD conditionUCD batch.of.sequencingB sexM\nCON1             1            0            0                    0    1\nCON2             1            0            0                    0    1\nCON3             1            0            0                    0    0\nCON4             1            0            0                    0    0\nCON5             1            0            0                    0    1\nCON6             1            0            0                    0    1\n     RNA.concentration\nCON1        -0.7021056\nCON2        -0.4025453\nCON3        -0.6073147\nCON4        -0.5172371\nCON5        -0.1783988\nCON6        -0.6052199\n\n\nNow we specify the comparisons we want to make. There are many possible combinations we can investigate here, for example: untreated celiac disease vs control, untreated celiac disease vs treated celiac disease, and so on… When working on your own analysis think about the biological questions you want to answer and define the contrasts accordingly.\n\ncontrasts_matrix &lt;- makeContrasts(\n    UCDvsCTRL = conditionUCD - conditionCTRL,\n    TCDvsCTRL = conditionTCD - conditionCTRL,\n    UCDvsTCD = conditionUCD - conditionTCD,\n    levels = colnames(design)\n)\nhead(contrasts_matrix)\n\n                      Contrasts\nLevels                 UCDvsCTRL TCDvsCTRL UCDvsTCD\n  conditionCTRL               -1        -1        0\n  conditionTCD                 0         1       -1\n  conditionUCD                 1         0        1\n  batch.of.sequencingB         0         0        0\n  sexM                         0         0        0\n  RNA.concentration            0         0        0\n\n\nNow that we have our models and contrasts, we are finally ready to find the DEGs.\n\n\nFit the model and find DEGs\nIn the following steps we perform the necessary steps to fit the model and extract the DEGs for the comparisons we want. The function voom transforms the raw counts and stabilized variance, so the data can be modeled with limma’s linear model.\n\nv &lt;- voom(y_filtered, design, plot=TRUE) # change to FALSE if you don't want the plot\n\n\n\n\n\n\n\n\nThe plot generated by voom is a diagnostic tool that visualizes the relationship between a gene’s average expression and its variance. The plot above is a example of a good plot: it has a “smooth”, downward-sloping trend line, showing that voom has captured the mean-variance relationship. A bad plot usually has “peaks” and looks irregular, suggesting there is a problem with the data, such as bad filtering of lowly expressed genes or technical issues.\nNow we fit the model to the voom-transformed data and extract the results.\n\n# Fit the model\nfit &lt;- lmFit(v, design)\nfit2 &lt;- contrasts.fit(fit, contrasts_matrix[, \"UCDvsCTRL\"]) # here is where you specify the contrast you want the results for\nfit2 &lt;- eBayes(fit2)\n\n# Get the table with results\nres &lt;- topTable(fit2, sort.by = \"P\", n = Inf) # this returns the table with the results for all the genes, ordered by p-value\nknitr::kable(head(res))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngenes\nlogFC\nAveExpr\nt\nP.Value\nadj.P.Val\nB\n\n\n\n\nENSG00000117228\nENSG00000117228\n1.9855499\n6.367871\n13.50997\n0\n0\n40.64992\n\n\nENSG00000092010\nENSG00000092010\n0.7266291\n7.670674\n12.78049\n0\n0\n37.62139\n\n\nENSG00000204264\nENSG00000204264\n1.1348134\n6.870195\n12.75139\n0\n0\n37.49876\n\n\nENSG00000148773\nENSG00000148773\n2.7271550\n6.506489\n12.70288\n0\n0\n37.28963\n\n\nENSG00000182054\nENSG00000182054\n1.7045698\n6.584646\n12.47710\n0\n0\n36.33895\n\n\nENSG00000182481\nENSG00000182481\n2.0288446\n4.891909\n12.29831\n0\n0\n35.47388\n\n\n\n\n\nThese are the results for just untreated celiac disease vs control. Instead of running the code above multiple times for each comparison, we can do this iterative for all comparisons.\n\nres_all &lt;- list()\nfor (x in colnames(contrasts_matrix)) {\n  \n  contr &lt;- contrasts_matrix[, x]\n  \n  fit2 &lt;- contrasts.fit(fit, contr)\n  fit2 &lt;- eBayes(fit2)\n  res &lt;- topTable(fit2, sort.by = \"P\", n = Inf)\n  res$Contrast &lt;- x\n  res_all &lt;- append(res_all, list(res))\n    \n}\nresults &lt;- list_rbind(res_all)\nknitr::kable(head(results))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngenes\nlogFC\nAveExpr\nt\nP.Value\nadj.P.Val\nB\nContrast\n\n\n\n\nENSG00000117228…1\nENSG00000117228\n1.9855499\n6.367871\n13.50997\n0\n0\n40.64992\nUCDvsCTRL\n\n\nENSG00000092010…2\nENSG00000092010\n0.7266291\n7.670674\n12.78049\n0\n0\n37.62139\nUCDvsCTRL\n\n\nENSG00000204264…3\nENSG00000204264\n1.1348134\n6.870195\n12.75139\n0\n0\n37.49876\nUCDvsCTRL\n\n\nENSG00000148773…4\nENSG00000148773\n2.7271550\n6.506489\n12.70288\n0\n0\n37.28963\nUCDvsCTRL\n\n\nENSG00000182054…5\nENSG00000182054\n1.7045698\n6.584646\n12.47710\n0\n0\n36.33895\nUCDvsCTRL\n\n\nENSG00000182481…6\nENSG00000182481\n2.0288446\n4.891909\n12.29831\n0\n0\n35.47388\nUCDvsCTRL\n\n\n\n\n\nThis list have the genes with their Ensembl ID, to help with interpretation we will add the gene symbol and entrezid annotation before we continue.\n\nmart &lt;- useEnsembl(biomart = \"ensembl\", dataset = \"hsapiens_gene_ensembl\")\ngenemap &lt;- getBM(attributes = c(\"ensembl_gene_id\", \"hgnc_symbol\", \"entrezgene_id\"),\n                 filters = \"ensembl_gene_id\",\n                 values = unique(results$genes),\n                 mart = mart)\n                        \nresults &lt;- left_join(results, genemap, by = join_by(\"genes\" == \"ensembl_gene_id\"), relationship = 'many-to-many')\nknitr::kable(head(results))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngenes\nlogFC\nAveExpr\nt\nP.Value\nadj.P.Val\nB\nContrast\nhgnc_symbol\nentrezgene_id\n\n\n\n\nENSG00000117228\n1.9855499\n6.367871\n13.50997\n0\n0\n40.64992\nUCDvsCTRL\nGBP1\n2633\n\n\nENSG00000092010\n0.7266291\n7.670674\n12.78049\n0\n0\n37.62139\nUCDvsCTRL\nPSME1\n5720\n\n\nENSG00000204264\n1.1348134\n6.870195\n12.75139\n0\n0\n37.49876\nUCDvsCTRL\nPSMB8\n5696\n\n\nENSG00000148773\n2.7271550\n6.506489\n12.70288\n0\n0\n37.28963\nUCDvsCTRL\nMKI67\n4288\n\n\nENSG00000182054\n1.7045698\n6.584646\n12.47710\n0\n0\n36.33895\nUCDvsCTRL\nIDH2\n3418\n\n\nENSG00000182481\n2.0288446\n4.891909\n12.29831\n0\n0\n35.47388\nUCDvsCTRL\nKPNA2\n3838\n\n\n\n\n\nWe can also create a dataframe containing only the significant results. Here we are considering significant the genes with absolute log2FC &gt; 1 and adjusted p-value &lt; 0.05.\n\nresults_significant &lt;- results |&gt;\n    dplyr::filter(abs(logFC &gt; 1) & adj.P.Val &lt; 0.05)\n\n# Save the results\n# Specify the path to the folder you want to save the results\nfolder_path &lt;- \"results\"\n\n# Check if the folder exists\nif (!dir.exists(folder_path)) {\n  # If it doesn't exist, create it\n  dir.create(folder_path)\n  cat(paste0(\"Folder '\", folder_path, \"' created successfully!\\n\"))\n} else {\n  cat(paste0(\"Folder '\", folder_path, \"' already exists.\\n\"))\n}\n\nFolder 'results' already exists.\n\nwrite.csv(results, paste0(folder_path, \"/DEG_results_biopsies_oslo.csv\"), row.names=F)\nwrite.csv(results_significant, paste0(folder_path, \"/DEG_results_biopsies_oslo_significant_only.csv\"), row.names=F)",
    "crumbs": [
      "Bulk RNA-seq data analysis"
    ]
  },
  {
    "objectID": "Bulk_RNAseq_Tutorial.html#visualization",
    "href": "Bulk_RNAseq_Tutorial.html#visualization",
    "title": "Bulk RNA-seq data analysis",
    "section": "Visualization",
    "text": "Visualization\n\nVolcano plot\nNow we can visualize the DEGs in a volcano plot, which plots the -log10(padj) against the fold change of the genes. This allows for easy identification of data points that show both significant changes and large magnitudes of change.\n\n# Define a function to make a volcano plot\n# Makes a volcano plot, highlighting the genes above the specified log2FC threshold and labels the top n genes (based on padj)\nVolcanoPlot &lt;- function(res, threshold = 0.5, p_cutoff = 0.05, n_labels = 15, title = '') {\n    # Prepare the data\n  res_plot &lt;- res |&gt;\n    mutate(DE = case_when(\n      adj.P.Val &lt; p_cutoff & logFC &gt;= threshold ~ 'upregulated',\n      adj.P.Val &lt; p_cutoff & logFC &lt;= -threshold ~ 'downregulated',\n      adj.P.Val &gt;= p_cutoff | abs(logFC) &lt; threshold ~ 'not DE'\n    ))\n  \n  # Add label to the top n genes (ranked by FC)\n  n &lt;- n_labels\n  \n  top_genes &lt;- res_plot |&gt; dplyr::filter(DE != 'not DE') |&gt; \n    group_by(sign(logFC)) |&gt; \n    top_n(n_labels, -log10(adj.P.Val)) |&gt; \n    pull(hgnc_symbol)\n  res_plot$genelabel &lt;- ''\n  res_plot$genelabel[res_plot$hgnc_symbol %in% top_genes] &lt;- res_plot$hgnc_symbol[res_plot$hgnc_symbol %in% top_genes]\n  \n  color_map &lt;- c(\"not DE\" = \"gray\", \"downregulated\" = \"#2166ac\", \"upregulated\" = \"#b2182b\")\n  \n  ggplot(res_plot, aes(x = logFC, y = -log10(adj.P.Val))) +\n    geom_point(aes(colour = DE), size = 1.5) +\n    geom_text_repel(aes(label = genelabel), min.segment.length = 0.25, force = 10) +\n    geom_hline(yintercept = -log10(p_cutoff), colour = '#696969', linetype = 'dashed') +\n    geom_vline(xintercept = -threshold, colour = '#696969', linetype = 'dashed') +\n    geom_vline(xintercept = threshold, colour = '#696969', linetype = 'dashed') +\n    scale_color_manual('', values = color_map) +\n    default_theme() +\n    theme(legend.text = element_text(size = rel(1.25))) +\n    labs(title = title,\n         x = 'log2 fold change',\n         y = '-log10 adjusted p-value')\n  \n}\n\nLike before, we do this in a iterative way to make the volcano plots for all comparisons at the same time. You can change the log2FC threshold or the p_cutoff based on your cut-offs for a gene to be considered DE.\n\nvolcanos &lt;- list()\nfor(c in unique(results$Contrast)) {\n    data &lt;- dplyr::filter(results, Contrast == c)\n    p &lt;- VolcanoPlot(data, threshold = 0.5, p_cutoff = 0.05, n_labels = 15, title = c)\n    volcanos &lt;- append(volcanos, list(p))\n}\nwrap_plots(volcanos, guides = 'collect')\n\n\n\n\n\n\n\n\n\n\nHeatmap\nWe can also visualize the DEGs in a heatmap. Heatmaps are color coded, graphical representations of a matrix. The rows and columns of this matrix can be arranged in a certain way to showcase the similarities between columns and rows. This arrangement of columns and rows can be used an unsupervised approach such as hierarchical clustering, which can be useful to find patterns in the data, such as cluster of genes that are down/up-regulated with similar magnitude. It is also useful to visualize the gene expression per sample. To create this plot we use the expression data as logCPM from the significant genes.\n\n# Choose a contrast to visualize\ncontrast &lt;- 'UCDvsCTRL'\n\n# Get the DEGs for this contrast\nde_genes &lt;- results_significant$genes[results_significant$Contrast == contrast]\n\n# Get the logCPM counts for these genes\ncpm_de &lt;- cpm(y_filtered, log = TRUE)\ncpm_de &lt;- cpm_de[de_genes,]\n\n# Calculates z-score\nz &lt;- t(scale(t(cpm_de)))\n\n# Create annotation dataframe for the heatmap - this can be whatever you want to show about the samples (columns)\nannotation_col &lt;- y_filtered$samples[colnames(z), c('condition', 'marsh.score')]\nrownames(annotation_col) &lt;- y_filtered$samples[colnames(z), 'sample']\nann_colors &lt;- list(\n    condition = c('CTRL' = '#29d3d6',\n                 'TCD' = '#29d62e',\n                 'UCD' = '#910a0a'),\n    marsh.score = c('n.m.' = '#FEE5D9',\n                   '0' = '#FCAE91',\n                   '1' = '#FB6A4A',\n                   '2' = '#DE2D26',\n                   '3' = '#A50F15'))\n\n# Make the heatmap with values scaled by row (genes), so you can compare between samples (columns)\npheatmap(z, cluster_rows = T, show_rownames = F, show_colnames = F, border_color = NA,\n        color = colorRampPalette(rev(brewer.pal(n = 7, name = \"RdBu\")))(100),\n        annotation_col = annotation_col,\n        annotation_colors = ann_colors,\n        treeheight_col = FALSE)\n\n\n\n\n\n\n\n\n\n\nData points\nIn some cases it’s also useful to visualize the expression values for certain genes across all samples. Lets check for the top 10 DEGs between untreated celiacs and controls. Remember, in order to properly compare expression values across samples we need to use the normalized levels (in this case logCPM).\n\n# Select the top 10 genes (based on adj p-val) for UCDvsCTRL\ntop10_genes &lt;- results_significant |&gt;\n    dplyr::filter(Contrast == 'UCDvsCTRL') |&gt;\n    top_n(-10, adj.P.Val)\n\n# Get the cpm counts\ntop10_cpm &lt;- cpm(y_filtered, log=TRUE)\ntop10_cpm &lt;- as.data.frame(cpm[top10_genes$genes,])\ntop10_cpm$symbol &lt;- top10_genes$hgnc_symbol # add the gene symbol\n\n# Reshape the data so we can plot\ndata_plot &lt;- melt(top10_cpm)\n\nUsing symbol as id variables\n\n# Add sample information (condition)\ndata_plot &lt;- left_join(data_plot, y_filtered$samples[, c('sample', 'condition')], by = join_by(\"variable\" == \"sample\"))\n\ntop10_Plot &lt;- ggplot(data_plot, aes(x = condition, y = value))+\n                geom_jitter(alpha=0.8)+\n                geom_boxplot(alpha=0.6)+\n                facet_grid(~symbol, scale=\"free\")+\n                ylab(\"logCPM\")+\n                xlab(\"\")+\n                default_theme()+\n                theme(axis.text.x = element_text(angle=45, hjust = 1))\ntop10_Plot\n\n\n\n\n\n\n\n\nNow we have our DEGs and many ways to visualize them. But what do they do? How are they biologically relevant?\nMost of the times we have hundreds or thousands of DEGs, so it might be hard to look at them individually and check their function. To deal with that, we can do a pathway analysis to find if the DEGs are involved in common pathways that are enriched in the results.",
    "crumbs": [
      "Bulk RNA-seq data analysis"
    ]
  },
  {
    "objectID": "Bulk_RNAseq_Tutorial.html#pathway-analysis",
    "href": "Bulk_RNAseq_Tutorial.html#pathway-analysis",
    "title": "Bulk RNA-seq data analysis",
    "section": "Pathway analysis",
    "text": "Pathway analysis\nTo find if our DEGs are enriched for a particular biological function we can use a Over Representation Analysis (ORA) or a Gene Set Enrichment Analysis (GSEA). ORA is a method to find if known biological functions are over-represented in a given list of genes (e.g. DEGs), comparing to a background of all genes measures. A limitation of this method is that it doesn’t take into account how much the expression of a gene changes (i.e. the log2 fold-change). GSEA, on the other hand, uses the log2 fold-change information to rank all genes and calculate an enrichment score that reflects how clustered the genes from a particular set are at the top (upregulated) or bottom (downregulated) of the ranked list. There are many tools and databases with gene biological function that you can use, in this tutorial we will use the package clusterProfiler and the databases gene ontology, KEGG, and Reactome.\n\nPrepare the data\nLoad the results from the DE analysis. Here let’s use all genes that are significant (adj. p-value &lt; 0.05) but without filtering for the fold-change, so we can see how the results from ORA and GSEA will differ from each other. In your own analysis, you can set a fold-change cut-off as well if necessary. Besides, we need the Entrezid for most of the methods so we will filter out genes that don’t have one.\n\n# Load the results and keep only the significant genes and remove genes without entrezid\nresults &lt;- read.csv('results/DEG_results_biopsies_oslo.csv')\nresults_sig &lt;- results |&gt; \n    filter(adj.P.Val &lt; 0.05 & !is.na(entrezgene_id))\n\n\n\nOver Representation Analysis\nThe function compareCluster allows us to run ORA for the three comparisons and two directions (up or downregulated) at the same time. The function needs a formula specifying how you want to run the comparison. To tell we want the analysis per contrast and for each direction in that contrast we use the formula entrezgene_id ~ Contrast + direction. In this analysis, you can also specify a “universe”: a list of all genes that were tested in your analysis, to be used as a background. (This block of code might take a few minutes to run.)\n\n# Create a column with direction of DE\nresults_sig$direction &lt;- if_else(results_sig$logFC &gt; 0, \"upregulated\", \"downregulated\")\n\n# Get the universe - all genes tested\nuniverse &lt;- results |&gt; filter(!is.na(entrezgene_id)) |&gt; pull(entrezgene_id)\n\n# Run ORA using gene ontology biological process\nora_go &lt;- compareCluster(entrezgene_id ~ Contrast + direction,\n                        fun = 'enrichGO',\n                        universe = universe,\n                        ont = \"BP\",\n                        OrgDb = org.Hs.eg.db,\n                        data = results_sig,\n                        pvalueCutoff = 0.05,\n                        readable = TRUE)\n\n# Run ORA using KEGG Pathway\nora_kegg &lt;- compareCluster(entrezgene_id ~ Contrast + direction,\n                        fun = 'enrichKEGG',\n                        universe = universe,\n                        organism = \"hsa\",\n                        data = results_sig,\n                        pvalueCutoff = 0.05)\n\n# Run ORA using Reactome\nora_reactome &lt;- compareCluster(entrezgene_id ~ Contrast + direction,\n                        fun = 'enrichPathway',\n                        universe = universe,\n                        organism = \"human\",\n                        data = results_sig,\n                        pvalueCutoff = 0.05,\n                        readable = TRUE)\n\nThese objects contain a lot of information about the test and results. You can access the table with results with @compareClusterResult, for example:\n\nknitr::kable(head(ora_go@compareClusterResult))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCluster\nContrast\ndirection\nID\nDescription\nGeneRatio\nBgRatio\nRichFactor\nFoldEnrichment\nzScore\npvalue\np.adjust\nqvalue\ngeneID\nCount\n\n\n\n\nUCDvsCTRL.downregulated\nUCDvsCTRL\ndownregulated\nGO:0006631\nfatty acid metabolic process\n106/1700\n405/18986\n0.2617284\n2.923044\n12.267746\n0\n0\n0\nPCK1/ACAT1/ACADM/CYP3A4/CYP2J2/LPIN2/LIPA/ABHD6/CD36/EPHX1/CYP2C9/ASAH2/ABHD2/HACL1/ACSF2/PRKAB2/CYP4F2/ECHDC2/GPX4/RGN/APPL2/CYP4V2/ACOX1/APOA4/ACBD4/NAAA/PTGR1/APOC3/HADHB/ACAA1/MLXIPL/PDK4/DEGS1/NR1H3/CYP2D6/CYP4F12/BDH2/CROT/CRAT/CRYL1/HPGD/PCK2/PDK2/ACBD5/ACSS1/ABCD4/ACSL5/PHYH/GSTM2/PPARA/HACD2/KAT2B/CES2/SLC27A4/ACADSB/GGT1/ETFDH/FABP2/SIRT2/CYP2S1/CYP2C18/ACOX2/ACAA2/ABHD5/UGT1A10/ABHD12/CYP2C19/ASAH1/CYP4F3/ADH4/SGPL1/INSIG2/ACADVL/CEACAM1/WDTC1/PPARG/LPGAT1/PRKAG2/SCP2/UBR4/DCAF5/ABCD1/ALOX5/SESN2/HPGDS/PDK3/PTGS1/AIG1/ALDH3A2/ALOX5AP/SCAP/ACOT11/CBR1/HADHA/TNFRSF1A/LPIN3/NR1H2/ABCD3/PEX5/ACSL1/CPT2/SREBF1/MGLL/AUH/ACADS/MGST3\n106\n\n\nUCDvsCTRL.downregulated\nUCDvsCTRL\ndownregulated\nGO:0046486\nglycerolipid metabolic process\n96/1700\n385/18986\n0.2493506\n2.784807\n11.095220\n0\n0\n0\nPCK1/APOA1/LPIN2/LIPA/APOB/ABHD6/ABHD2/SERINC1/SORL1/SCARB1/RGN/APOA4/NAAA/DGAT2/DGKA/ENPP2/APOC3/GK/DGAT1/LPCAT3/DDHD2/NR1H3/AGPAT3/PIP4K2A/PCK2/PDGFA/G6PC1/PLCH2/PIP4P1/MTMR11/MTMR4/MTMR3/TTC7A/GPAM/CIDEC/GPD1/INPP5K/GPAT3/ABHD5/CDIPT/PIK3R5/ABHD12/PI4K2B/SLC44A4/APOBEC1/MBOAT7/INSIG2/GK5/PNPLA2/LPGAT1/PIKFYVE/CAT/AVIL/PI4KA/PAFAH1B1/MTTP/PGS1/PIP5K1C/CDK8/BMX/PI4KB/PLCG2/MOGAT2/AADAC/HYCC2/MECP2/GPCPD1/CHKA/CEPT1/TAFAZZIN/PIP5K1B/ABHD4/MTMR12/HADHA/PGAP3/MOGAT3/LPIN3/PCYT1A/INPP5J/IPMK/PISD/NR1H2/PIK3CG/ACSL1/PNPLA6/SREBF1/PRDX6/MGLL/CDS2/INPP4A/SLC44A2/PCYT2/MTMR10/PLCB2/PLCG1/INPP5B\n96\n\n\nUCDvsCTRL.downregulated\nUCDvsCTRL\ndownregulated\nGO:0044242\ncellular lipid catabolic process\n71/1700\n238/18986\n0.2983193\n3.331700\n11.351840\n0\n0\n0\nPCK1/ACAT1/ACADM/LPIN2/APOB/ABHD6/ASAH2/ABHD2/HACL1/SORL1/SCARB1/CYP4F2/ECHDC2/ACOX1/APOA4/LCT/ENPP2/APOC3/HADHB/ACAA1/DDHD2/ENPP7/GALC/CYP4F12/BDH2/NEU1/CROT/CRAT/PCK2/GBA3/ABCD4/SMPD1/FUCA1/PHYH/PPARA/SLC27A4/AKR1B10/ETFDH/SIRT2/ACOX2/SMPD3/ACAA2/ABHD5/PRKCD/ABHD12/ASAH1/CYP4F3/SGPL1/ACADVL/ALDH3B1/PNPLA2/SCP2/ABCD1/SESN2/AIG1/PLCG2/AADAC/GPCPD1/NAGA/HADHA/LPIN3/ABCD3/PIK3CG/PEX5/CPT2/PNPLA6/PRDX6/MGLL/AUH/ACADS/PLCG1\n71\n\n\nUCDvsCTRL.downregulated\nUCDvsCTRL\ndownregulated\nGO:0016042\nlipid catabolic process\n89/1700\n351/18986\n0.2535613\n2.831832\n10.863179\n0\n0\n0\nPCK1/ACAT1/ACADM/CYP3A4/LPIN2/LIPA/APOB/ABHD6/ASAH2/ABHD2/HACL1/SORL1/SCARB1/CYP4F2/ECHDC2/ACOX1/APOA4/HSD17B11/NAAA/LCT/ENPP2/APOC3/HADHB/ACAA1/DPEP1/ABHD15/DDHD2/ENPP7/GALC/CYP4F12/BDH2/NEU1/CROT/CRAT/HPGD/PCK2/GBA3/PLCH2/ABCD4/SMPD1/FUCA1/PHYH/PPARA/SLC27A4/AKR1B10/ETFDH/SIRT2/CIDEC/ACOX2/SULT2A1/SMPD3/ACAA2/ABHD5/PLA2G12B/PRKCD/ABHD12/ASAH1/CYP4F3/SGPL1/ACADVL/ALDH3B1/PNPLA2/SCP2/PAFAH1B1/ABCD1/SESN2/THRA/AIG1/CYP27A1/PLCG2/AADAC/GPCPD1/NAGA/ABHD4/HADHA/SCT/LPIN3/CRTC3/ABCD3/PIK3CG/PEX5/CPT2/PNPLA6/PRDX6/MGLL/AUH/ACADS/PLCB2/PLCG1\n89\n\n\nUCDvsCTRL.downregulated\nUCDvsCTRL\ndownregulated\nGO:0044282\nsmall molecule catabolic process\n83/1700\n375/18986\n0.2213333\n2.471903\n9.028018\n0\n0\n0\nPCK1/ALDOB/ACAT1/ACADM/CYP3A4/LPIN2/SORD/ABHD2/HACL1/SCARB1/OAT/CYP4F2/ECHDC2/SULT1B1/PRODH/ACOX1/GDA/GK/HADHB/ACAA1/DPEP1/IDS/QPRT/CYP4F12/BDH2/CROT/CRAT/ENPP4/CRYL1/SLC25A44/SHMT1/PCK2/GLS/ACSS1/ABCD4/GNPDA1/HGD/PHYH/PPARA/SLC27A4/ACADSB/AKR1B10/SULT1A2/ETFDH/DERA/ACOX2/SULT2A1/ACAA2/CYP4F3/ADH4/ACADVL/ALDH3B1/ADA2/GK5/DLST/HAGH/ADA/SCP2/ABCD1/ENTPD7/ABAT/SESN2/IDNK/DPYD/AIG1/CYP27A1/ENTPD4/NAGK/HADHA/LPIN3/HMGCL/PPM1K/ABCD3/RBKS/PEX5/PGM1/SULT1A1/CPT2/GLUD1/AUH/ACADS/ALDH6A1/MGAT1\n83\n\n\nUCDvsCTRL.downregulated\nUCDvsCTRL\ndownregulated\nGO:0006639\nacylglycerol metabolic process\n44/1700\n135/18986\n0.3259259\n3.640017\n9.653593\n0\n0\n0\nPCK1/LPIN2/LIPA/APOB/ABHD6/ABHD2/SORL1/SCARB1/RGN/APOA4/DGAT2/DGKA/APOC3/GK/DGAT1/DDHD2/NR1H3/PCK2/G6PC1/GPAM/CIDEC/GPAT3/ABHD5/ABHD12/APOBEC1/MBOAT7/INSIG2/GK5/PNPLA2/LPGAT1/CAT/AVIL/MTTP/PGS1/CDK8/MOGAT2/AADAC/MOGAT3/LPIN3/NR1H2/PIK3CG/ACSL1/SREBF1/MGLL\n44\n\n\n\n\n\nYou can visualize the results in many different ways, check the documentation of this package to see all options. For simplicity, we will plot only the dot plot here but explore other ways to visualize in your own analysis.\n\ndotplot(ora_go) +\n    default_theme() +\n    theme(axis.text.x = element_text(angle=45, hjust = 1))\n\n\n\n\n\n\n\n\n\n\nGene Set Enrichment Analysis (GSEA)\nBecause GSEA uses the log2 fold-change to rank the genes, we first need to prepare this input vector with genes ordered based on their fold-change. In this case, we will not use compareCluster to do everything all at once, instead we will use a custom function to prepare the data and run the analysis. We don’t need the universe genes in this case.\n\n# Define the function to create the ranked gene list and run the analysis\nrun_gsea &lt;- function(data, contrast, database = c('GO-BP', 'KEGG', 'Reactome')) {\n\n  # Creates the ordered gene list for given contrast\n  foldchanges &lt;- data$logFC[data$Contrast == contrast]\n  names(foldchanges) &lt;- data$entrezgene_id[data$Contrast == contrast]\n  foldchanges &lt;- sort(foldchanges, decreasing = TRUE)\n\n  # Run the analysis for given database\n  if(database == 'GO-BP') {\n    res &lt;- gseGO(geneList = foldchanges, OrgDb = \"org.Hs.eg.db\", keyType = \"ENTREZID\", ont = \"BP\", pvalueCutoff = 0.05)\n  } else if(database == 'KEGG') {\n    res &lt;- gseKEGG(geneList = foldchanges, organism = 'hsa', pvalueCutoff = 0.05)\n  } else if(database == 'Reactome') {\n    res &lt;- gsePathway(geneList = foldchanges, organism = 'human', pvalueCutoff = 0.05)\n  } else {\n    print(\"Choose a database among GO-BP, KEGG or Reactome.\")\n  }\n  return(res)\n\n}\n\nNow apply the function to our contrasts. For simplicity, we will do only for GO-BP.\n\ngsea_ucd_ctrl &lt;- run_gsea(results_sig, contrast = 'UCDvsCTRL', database = 'GO-BP')\n\nusing 'fgsea' for GSEA analysis, please cite Korotkevich et al (2019).\n\n\npreparing geneSet collections...\n\n\nGSEA analysis...\n\n\nleading edge analysis...\n\n\ndone...\n\ngsea_ucd_tcd &lt;- run_gsea(results_sig, contrast = 'UCDvsTCD', database = 'GO-BP')\n\nusing 'fgsea' for GSEA analysis, please cite Korotkevich et al (2019).\n\n\npreparing geneSet collections...\n\n\nGSEA analysis...\n\n\nleading edge analysis...\n\n\ndone...\n\n# Converts entrezid back to symbol\ngsea_ucd_ctrl &lt;- setReadable(gsea_ucd_ctrl, org.Hs.eg.db)\ngsea_ucd_tcd &lt;- setReadable(gsea_ucd_tcd, org.Hs.eg.db)\n\nSimilarly to ORA, we can check the results with @result. Note a column called NES, this is the Normalized Enrichment Score and the most important metric here to interpret the results. The NES is derived from the enrichment score (ES), a value that reflects the degree to which a gene set is overrepresented at the top (upregulated, positive ES) or bottom (downregulated, negative ES) of a ranked gene list. This score is calculated by a “random walk” algorithm that increases a running sum when it encounters a gene from the set and decreases it otherwise. The final ES is the maximum deviation from zero during this walk.\n\nknitr::kable(head(gsea_ucd_ctrl))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nID\nDescription\nsetSize\nenrichmentScore\nNES\npvalue\np.adjust\nqvalue\nrank\nleading_edge\ncore_enrichment\n\n\n\n\nGO:0051276\nGO:0051276\nchromosome organization\n191\n0.5468616\n3.200047\n0\n0\n0\n984\ntags=57%, list=26%, signal=44%\nCDC20/TPX2/CCNB1/TOP2A/CENPE/KIF11/CENPF/NUSAP1/RACGAP1/HMGB3/HMGB2/REC8/MCM4/MYC/NDC1/SMC2/EZH2/TACC3/RCC1/SMC4/MCM3/PCNA/MCM5/KNTC1/KNL1/MCM7/CENPX/INCENP/RUVBL2/GNL3/HMGA1/NCAPD2/KIF22/CCT2/DKC1/RAN/ANAPC1/NASP/ERN2/PRKDC/NUP107/NCAPD3/MSH2/HSP90AA1/CCT5/LMNA/HSP90AB1/CCT3/MCM6/BANF1/NBN/PTGES3/TP53/HMGB1/SMARCC1/SSBP1/SMARCB1/NAT10/HNRNPC/HAT1/ACTL6A/NUP155/CCT7/RAD21/KPNB1/CCT6A/CDC27/BCCIP/XRCC6/TCP1/PARP1/CCT8/HNRNPA1/ITPA/XRCC5/CCT4/SMARCA4/PML/NOP10/HSPA1B/ATR/ACTB/HNRNPU/H3-3B/SUB1/KMT5A/PPP2R1A/DRG1/G3BP1/PHB2/STAG1/PBRM1/NUP133/RAB11A/NUDC/HNRNPA2B1/NUP62/MLH1/ASCC3/SMC1A/SEH1L/DHX9/DDX1/NAA50/HNRNPD/MCRS1/SMARCD2/CDK5RAP2/MCMBP\n\n\nGO:0098813\nGO:0098813\nnuclear chromosome segregation\n92\n0.5938188\n3.103159\n0\n0\n0\n265\ntags=29%, list=7%, signal=28%\nCDC20/TPX2/ASPM/CCNB1/TOP2A/CENPE/KIF11/CENPF/NUSAP1/AURKA/RACGAP1/ECT2/REC8/NDC1/SMC2/TACC3/RCC1/SMC4/KNTC1/KNL1/INCENP/NCAPD2/KIF22/RAN/ANAPC1/RCC2/NCAPD3\n\n\nGO:0007059\nGO:0007059\nchromosome segregation\n123\n0.5627398\n3.073093\n0\n0\n0\n265\ntags=26%, list=7%, signal=25%\nMKI67/CDC20/TPX2/ASPM/CCNB1/TOP2A/CENPE/KIF11/CENPF/NUSAP1/AURKA/RACGAP1/ECT2/REC8/GPSM2/NDC1/SMC2/TACC3/RCC1/SMC4/KNTC1/KNL1/CENPX/INCENP/NCAPD2/TUBB/KIF22/RAN/ANAPC1/RCC2/PLSCR1/NCAPD3\n\n\nGO:0033044\nGO:0033044\nregulation of chromosome organization\n93\n0.5742037\n3.006638\n0\n0\n0\n701\ntags=51%, list=19%, signal=42%\nCDC20/CCNB1/TOP2A/CENPE/CENPF/MYC/SMC2/TACC3/SMC4/KNTC1/KNL1/INCENP/RUVBL2/GNL3/NCAPD2/CCT2/DKC1/ANAPC1/NCAPD3/HSP90AA1/CCT5/LMNA/CCT3/NBN/PTGES3/TP53/SMARCC1/SMARCB1/NAT10/HNRNPC/ACTL6A/CCT7/RAD21/CCT6A/CDC27/TCP1/PARP1/CCT8/HNRNPA1/XRCC5/CCT4/SMARCA4/PML/ATR/ACTB/HNRNPU/H3-3B\n\n\nGO:1902850\nGO:1902850\nmicrotubule cytoskeleton organization involved in mitosis\n53\n0.6241039\n2.953389\n0\n0\n0\n202\ntags=28%, list=5%, signal=27%\nCDC20/TPX2/CCNB1/CENPE/KIF11/NUSAP1/STMN1/AURKA/RACGAP1/GPSM2/TACC3/RCC1/INCENP/CKAP5/RAN\n\n\nGO:0000819\nGO:0000819\nsister chromatid segregation\n72\n0.5863184\n2.901068\n0\n0\n0\n924\ntags=58%, list=25%, signal=45%\nCDC20/TPX2/CCNB1/TOP2A/CENPE/KIF11/CENPF/NUSAP1/RACGAP1/SMC2/TACC3/RCC1/SMC4/KNTC1/KNL1/INCENP/NCAPD2/KIF22/RAN/ANAPC1/NCAPD3/SMARCC1/SMARCB1/ACTL6A/RAD21/KPNB1/CDC27/BCCIP/SMARCA4/HSPA1B/ACTB/HNRNPU/KMT5A/PPP2R1A/DRG1/STAG1/PBRM1/RAB11A/NUDC/NUP62/SMC1A/SEH1L\n\n\n\n\n\nAgain, you can visualize the results in many ways. With the script below you can get an overview of the top 10 enriched pathways and the top 10 repressed pathways.\n\ndata &lt;- gsea_ucd_ctrl\nn &lt;- 10\n\ndata_plot &lt;- arrange(as.data.frame(data@result), desc(abs(NES))) %&gt;%\n    group_by(sign(NES)) %&gt;%\n    dplyr::slice(1:n)\n\nggplot(data_plot, showCategory = n*2,\n      aes(NES, fct_reorder(Description,NES), fill = -log10(p.adjust))) +\ngeom_col() +\ngeom_vline(xintercept = 0, colour = '#696969', linetype = 'dashed') +\nscale_fill_gradientn(colours=c(\"#b3eebe\", \"#46bac2\", \"#371ea3\"),\n                      guide=guide_colorbar(reverse=TRUE)) +\nlabs(x = 'Normalized Enrichment Score',\n     y = '') +\ndefault_theme() +\ntheme(text = element_text(size = 11))\n\n\n\n\n\n\n\n\nAnother interesting way of visualizing the GSEA results is the “running score” plot. For a given pathway, this plot shows the position of the genes in the ranked list and the enrichment score.\n\ngseaplot(gsea_ucd_ctrl, geneSetID = 1, title = gsea_ucd_ctrl$Description[1])\n\n\n\n\n\n\n\n\nNote the differences between the two methods, they won’t always give you the same results. Keep the differences between the two methods in mind when doing your analysis and interpreting the results.\n\n\n\n\n\n\nTip\n\n\n\nIt might be the case that you get a lot of significant pathways that are very similar to each other (just a different name for the same thing), which makes it hard to identify different biological processes that are enriched. If that happens, you can simplify the results using the following function:\n\nsimplified &lt;- pairwise_termsim(gsea)\nsimplified &lt;- simplify(simplified)\n\nYou can then use this object instead for plotting the most significant results.",
    "crumbs": [
      "Bulk RNA-seq data analysis"
    ]
  },
  {
    "objectID": "Bulk_RNAseq_Tutorial.html#conclusion",
    "href": "Bulk_RNAseq_Tutorial.html#conclusion",
    "title": "Bulk RNA-seq data analysis",
    "section": "Conclusion",
    "text": "Conclusion\nNow that you are familiar with the basics of RNA-sequencing analysis, have fun analyzing the data you generated during the week in the lab :)",
    "crumbs": [
      "Bulk RNA-seq data analysis"
    ]
  }
]