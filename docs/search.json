[
  {
    "objectID": "Bulk_RNAseq_Tutorial.html",
    "href": "Bulk_RNAseq_Tutorial.html",
    "title": "Bulk RNA-seq data analysis tutorial",
    "section": "",
    "text": "This tutorial is build on data from duodenal biopsies of active celiac disease, treated celiac disease, and control individuals, as described by Aarón Ramírez-Sánchez et al. (2024). Here you will learn the basics on how to import RNA-seq data, explore the data, build contrasts, perform differential expression analysis, and gene set enrichment analysis. We will use the packages edgeR and limma-voom during this course. You can read more about them in detail here:\n\nedgeR user guide: https://www.bioconductor.org/packages/devel/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf\nlimma user guide: https://www.bioconductor.org/packages/devel/bioc/vignettes/limma/inst/doc/usersguide.pdf"
  },
  {
    "objectID": "Bulk_RNAseq_Tutorial.html#introduction",
    "href": "Bulk_RNAseq_Tutorial.html#introduction",
    "title": "Bulk RNA-seq data analysis tutorial",
    "section": "",
    "text": "This tutorial is build on data from duodenal biopsies of active celiac disease, treated celiac disease, and control individuals, as described by Aarón Ramírez-Sánchez et al. (2024). Here you will learn the basics on how to import RNA-seq data, explore the data, build contrasts, perform differential expression analysis, and gene set enrichment analysis. We will use the packages edgeR and limma-voom during this course. You can read more about them in detail here:\n\nedgeR user guide: https://www.bioconductor.org/packages/devel/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf\nlimma user guide: https://www.bioconductor.org/packages/devel/bioc/vignettes/limma/inst/doc/usersguide.pdf"
  },
  {
    "objectID": "Bulk_RNAseq_Tutorial.html#initial-set-up",
    "href": "Bulk_RNAseq_Tutorial.html#initial-set-up",
    "title": "Bulk RNA-seq data analysis tutorial",
    "section": "Initial set-up",
    "text": "Initial set-up\n\nSet working directory\nIn this step, you set your working directory, that is, the folder in your computer where you are going to save your scripts, data and results.\n\npath &lt;- '/Users/nvribeiro/Library/CloudStorage/OneDrive-UMCG/Desktop/PhD/Others/BMS-BigData-Course-2025' # you need to change this to your own path\n\nsetwd(path)\n\n\n\nLoad libraries\nIf you haven’t done, check the file “Preparation for data analysis – Big Data Course BMS 2025” and follow the instructions to install/update R, RStudio and the packages that you will used in the analysis. Then load the libraries.\n\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(ggplot2)\nlibrary(knitr)\nlibrary(stringr)\nlibrary(patchwork)\nlibrary(edgeR)\nlibrary(clusterProfiler)\nlibrary(enrichplot)\nlibrary(org.Hs.eg.db)\nlibrary(ReactomePA)\nlibrary(viridis)\nlibrary(ggrepel)\nlibrary(purrr)\nlibrary(biomaRt)\nlibrary(pheatmap)\nlibrary(RColorBrewer)\nlibrary(reshape2)\nlibrary(variancePartition)\nlibrary(forcats)\n\n\n# Optional: define a default theme to be used in all plots\ndefault_theme &lt;- function(){\n  theme_bw() +\n    theme(panel.grid = element_blank(),\n          panel.border = element_rect(linewidth = 1),\n          axis.title = element_text(size = rel(1)),\n          axis.title.y.left = element_text(margin = margin(r = 10, unit = 'pt')),\n          axis.title.y.right = element_text(margin = margin(l = 10, unit = 'pt')),\n          axis.title.x.bottom = element_text(margin = margin(t = 10, unit = 'pt')),\n          plot.title = element_text(size = rel(1), hjust = 0.5, face = 'bold'),\n          axis.text = element_text(size = rel(1)),\n          axis.ticks.length = unit(5, 'pt'),\n          strip.background = element_rect(fill = \"#f5a9a9\", linewidth = 0),\n          strip.text = element_text(size = rel(1), color = \"black\")\n    )\n}\n\n\n\nLoad the dataset\nNow we load the dataset that you have previously downloaded and saved in your “data” folder. This file contains the reads mapped to the gene annotation and thus contains the raw data with which we will work.\n\ncounts &lt;- read.table(\"data/RNA_matrix.table\", header=TRUE)\nknitr::kable(head(counts))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCON1\nCON2\nCON3\nCON4\nCON5\nCON6\nCON7\nCON8\nCON9\nCON10\nCON11\nCON12\nCON13\nCON14\nCON15\nCON16\nCON17\nCON18\nCON19\nCON20\nCON21\nCON22\nCON23\nCON24\nCON25\nTCD1\nUCD1\nTCD2\nTCD3\nTCD4\nTCD5\nTCD6\nTCD7\nTCD8\nTCD9\nTCD10\nTCD11\nTCD12\nTCD13\nTCD14\nTCD15\nTCD16\nTCD17\nUCD2\nUCD3\nTCD18\nTCD19\nTCD20\nUCD4\nTCD21\nUCD5\nUCD6\nTCD22\nTCD23\nTCD24\nTCD25\nUCD7\nUCD8\nUCD9\nUCD10\nUCD11\nUCD12\nUCD13\nUCD14\nUCD15\nUCD16\nTCD26\nTCD27\nUCD17\nUCD18\nUCD19\nTCD28\nUCD20\nUCD21\nUCD22\nUCD23\nUCD24\nUCD25\nUCD26\nUCD27\nUCD28\nUCD29\n\n\n\n\nENSG00000000003\n306\n219\n280\n337\n528\n436\n334\n453\n483\n181\n407\n291\n392\n254\n400\n161\n406\n239\n215\n356\n340\n292\n645\n309\n385\n530\n887\n356\n62\n454\n375\n451\n285\n506\n337\n380\n289\n195\n468\n131\n383\n601\n161\n218\n333\n273\n505\n377\n405\n454\n372\n374\n281\n353\n354\n713\n474\n583\n438\n319\n388\n493\n280\n862\n471\n373\n316\n457\n480\n883\n674\n274\n519\n571\n398\n673\n523\n579\n950\n439\n776\n677\n\n\nENSG00000000005\n0\n0\n0\n0\n0\n0\n8\n0\n0\n1\n0\n0\n0\n0\n0\n0\n2\n0\n0\n2\n3\n2\n0\n0\n6\n0\n13\n0\n0\n0\n0\n0\n0\n0\n8\n0\n0\n0\n0\n0\n0\n10\n0\n0\n11\n0\n0\n0\n7\n6\n0\n0\n0\n0\n0\n0\n0\n15\n5\n1\n33\n0\n0\n0\n0\n0\n0\n1\n2\n44\n2\n0\n4\n2\n19\n0\n3\n0\n41\n54\n22\n10\n\n\nENSG00000000419\n462\n586\n240\n525\n760\n367\n411\n633\n620\n359\n363\n377\n395\n751\n551\n336\n495\n425\n687\n402\n462\n486\n269\n486\n518\n710\n928\n384\n757\n435\n326\n731\n556\n489\n537\n282\n685\n187\n496\n302\n500\n658\n474\n334\n365\n321\n518\n460\n540\n569\n166\n704\n376\n414\n519\n578\n854\n924\n789\n637\n634\n687\n326\n717\n431\n357\n275\n238\n493\n758\n580\n618\n574\n549\n475\n465\n398\n516\n1155\n775\n666\n516\n\n\nENSG00000000457\n327\n318\n374\n473\n429\n305\n409\n243\n248\n268\n283\n237\n279\n223\n170\n310\n354\n309\n200\n305\n237\n361\n187\n298\n431\n369\n355\n375\n261\n286\n142\n529\n196\n438\n424\n210\n322\n121\n351\n243\n226\n302\n256\n244\n185\n149\n364\n312\n260\n367\n471\n70\n377\n274\n181\n551\n467\n314\n322\n311\n348\n258\n147\n439\n368\n192\n260\n188\n276\n375\n297\n220\n223\n235\n177\n295\n235\n471\n530\n210\n235\n304\n\n\nENSG00000000460\n58\n41\n125\n134\n21\n69\n33\n34\n22\n33\n21\n45\n40\n83\n41\n33\n65\n59\n105\n61\n53\n65\n68\n54\n38\n76\n232\n120\n203\n100\n179\n71\n86\n37\n76\n33\n43\n33\n63\n52\n101\n70\n10\n35\n53\n21\n7\n41\n93\n64\n8\n150\n111\n52\n55\n51\n119\n169\n184\n61\n239\n65\n61\n119\n76\n57\n49\n40\n95\n114\n78\n6\n99\n81\n56\n52\n110\n109\n145\n21\n119\n37\n\n\nENSG00000000938\n827\n466\n491\n281\n458\n320\n467\n1111\n182\n367\n375\n391\n319\n748\n454\n629\n198\n315\n448\n371\n237\n326\n225\n372\n511\n426\n33\n375\n119\n66\n304\n345\n516\n302\n503\n262\n522\n194\n226\n384\n165\n114\n651\n823\n272\n137\n95\n173\n131\n489\n33\n299\n524\n192\n151\n796\n461\n465\n101\n275\n494\n261\n278\n199\n438\n130\n74\n268\n438\n71\n144\n366\n221\n180\n138\n90\n172\n608\n394\n355\n57\n86\n\n\n\n\n\nWe now have a dataframe where each row is a gene and each column is sample.\n\n\nPreparing the metadata\nDifferential expression analysis is the comparison of gene expression between one or more conditions while correcting for unwanted sources of variation. This information is usually stored in a metadata file, where you have many details about each sample such as condition, sex, age, etc. Here we load the metadata for this dataset.\n\nmetadata &lt;- read.csv('data/metadata_oslo_biopsies.csv', header=TRUE)\nrownames(metadata) &lt;- metadata$sample\n\n# Visualize the first rows\nknitr::kable(head(metadata))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsample\ncondition\nmarsh.score\nsex\nage\nH..pylori\nPPI\ncell.counts\nbatch.of.RNA.isolation\nbatch.of.sequencing\nRNA.concentration\nRIN.score\ntotal.reads\nGC.content\ncrypt.ratio..APOA4.KI67.\ngroup\n\n\n\n\nCON1\nCON1\nCTRL\nn.m.\nM\n37\nNA\nYes\n1500000\n2\nA\n2.28\n7.3\n2402861\n47.5\n1.487207\nMild inflammation\n\n\nCON2\nCON2\nCTRL\nn.m.\nM\n26\nNA\nYes\n1500000\n5\nA\n8.00\n7.9\n2644867\n46.0\n1.666809\nNon-inflamed\n\n\nCON3\nCON3\nCTRL\nn.m.\nF\n27\nNA\nNo\n1267000\n5\nA\n4.09\n8.1\n2548105\n47.0\n1.492771\nMild inflammation\n\n\nCON4\nCON4\nCTRL\nn.m.\nF\n38\nNA\nYes\n1620000\n4\nA\n5.81\n7.7\n2812289\n47.0\n1.697659\nNon-inflamed\n\n\nCON5\nCON5\nCTRL\nn.m.\nM\n86\nNA\nYes\n1800000\n3\nA\n12.28\n8.2\n2843597\n46.0\n1.631452\nNon-inflamed\n\n\nCON6\nCON6\nCTRL\nn.m.\nM\n65\nNA\nNo\n1800000\n3\nA\n4.13\n9.0\n1730893\n46.0\n1.447205\nMild inflammation\n\n\n\n\n# Make sure that the colnames of your count table are matching with the row names of your colData\n# Both of the comparisons below need to return TRUE\nall(rownames(metadata) %in% colnames(counts)) # check if all samples in the metadata are present in the counts\n\n[1] TRUE\n\nall(rownames(metadata) == colnames(counts)) # check if they are in the same order\n\n[1] FALSE\n\n# In this case all samples are in counts and metadata, but they are not in the same order.\n# To put them in the same order we run\ncounts &lt;- counts[, rownames(metadata)]\nall(rownames(metadata) == colnames(counts)) # now this is TRUE\n\n[1] TRUE"
  },
  {
    "objectID": "Bulk_RNAseq_Tutorial.html#quality-control-and-exploratory-analysis",
    "href": "Bulk_RNAseq_Tutorial.html#quality-control-and-exploratory-analysis",
    "title": "Bulk RNA-seq data analysis tutorial",
    "section": "Quality control and exploratory analysis",
    "text": "Quality control and exploratory analysis\nNow we are going to create the edgeR object that will contain all the information about our experiment. We need to give the counts table, the matching metadata and a optional grouping factor (which we are not using in this case).\n\ny &lt;- DGEList(counts = counts,\n            samples = metadata,\n            genes = rownames(counts))\n\n\nRemove poorly expressed genes\nAs we sequenced this data set very deeply, a lot of noise is also captured, which is most prevalent in lowly expressed genes. To reduce the size of our data set and to make the differential expression analysis more robust by including only well-expressed genes that are more likely to be biologically informative, we will remove poorly expressed genes.\nFirst we visualize the counts in a histogram, this will give us an overview of the expression and we can try to decide a cutoff based on this graph. Here we are plotting the distribution of counts as log10 count-per-million (CPM).\n\n# Histogram of log(CPM)\ncpm &lt;- cpm(y, log = TRUE)\nhist(cpm)\n\n# With the following lines we add arbitrary cut-offs to histogram\n# Cutoff of 10\nabline(v = log10(10), col = \"blue\",lwd = 2)\n# cutoff of 100\nabline(v = log10(100), col = \"purple\",lwd = 2)\n# cutoff of 500\nabline(v = log10(500), col = \"red\",lwd = 2)\n# cutoff of 1000\nabline(v = log10(1000), col = \"orange\",lwd = 2)\n\n\n\n\n\n\n\n\nYou will notice a bi-modal distribution, in which a large chunk of genes is barely expressed, and a smaller chuck is expressed much more. We see that the bump with highly expressed genes occurs after the purple line (100 counts), so we can use that as a cut-off or, if you want to focus only on the really highly expressed genes, 500 or 1000 counts. Here I chose 500.\nThe function we will use to filter, filterByExpr, allows us to specify some parameters as the minimum counts required, if you want to filter per group, or use a formula.\n\nkeep &lt;- filterByExpr(y,\n                    group = y$samples$condition, # considers the group when filtering - optional\n                    min.count = 500) # the number you decided based on the histogram above\n\ny_filtered &lt;- y[keep, , keep.lib.sizes=FALSE]\n\nprint(paste0(\"Number of genes before filtering: \", dim(y)[1]))\n\n[1] \"Number of genes before filtering: 53042\"\n\nprint(paste0(\"Number of genes after filtering: \", dim(y_filtered)[1]))\n\n[1] \"Number of genes after filtering: 6809\"\n\n\nWe now reduced our dataset from 53,042 genes to 6,809. This will help speed up the calculations and only focus on genes that are expressed at high levels and probably more biologically relevant.\n\n\nPrincipal component analysis (PCA)\nThe PCA can help assess which samples are more closely related to each other, and how much variation is found between samples. We can also use PCA to check if other variables in our metadata are unwanted sources of variation that should be included in the model. To calculate the PCA, we use the logCPM counts.\n\n\n\n\n\n\nTip\n\n\n\nIf you are not familiar with PCA, watch this video: https://www.youtube.com/watch?v=HMOI_lkzW08\n\n\n\n# First define a function to make easier to plot the PCs. This function makes a PCA plot for the any PCs specified in \"coord_1\" and \"coord_2\" and will group the points (color) by a metadata column specified in \"color_by\". \"coldata\" is your metadata (stored in the \"samples\" part of the edgeR object)\nplotPC &lt;- function(pca_obj, coldata, coord_1, coord_2, color_by) {\n\n  var_explained &lt;- pca$sdev^2 / sum(pca$sdev^2)\n  var_explained_df &lt;- tibble(PC = paste0('PC', seq_along(var_explained)),\n                             Var_Explained = var_explained)\n  \n  df &lt;- as.data.frame(cbind(coldata, pca$x))\n  \n  x_label &lt;- paste0(coord_1, ' (', round(var_explained_df$Var_Explained[var_explained_df$PC == coord_1]*100, digits = 2), '%)')\n  y_label &lt;- paste0(coord_2, ' (', round(var_explained_df$Var_Explained[var_explained_df$PC == coord_2]*100, digits = 2), '%)')\n  \n  p &lt;- ggplot(df, aes(x = !!sym(coord_1), y = !!sym(coord_2), color = as.factor(!!sym(color_by)))) +\n    geom_point(size = 3) +\n    scale_color_viridis_d() +\n    labs(x = x_label, y = y_label) +\n    default_theme()\n  \n  return(p)\n  \n}\n\n# The next function we define is to create a scree plot\n# Makes a Scree plot based on the PCA results, if n_pcs = NULL, plots all available PCs\nplotScree &lt;- function(pca, n_pcs = NULL){\n  \n  if (is.null(n_pcs)){\n    n_pcs &lt;- ncol(pca$x)\n  }\n  \n  # Extract variance explained\n  var_explained &lt;- pca$sdev^2 / sum(pca$sdev^2)\n  cumulative_var &lt;- cumsum(var_explained)\n  \n  # Create a data frame for plotting\n  plot_data &lt;- data.frame(\n    PC = seq_along(var_explained),\n    Variance_Explained = var_explained,\n    Cumulative_Explained = cumulative_var\n  )\n  \n  plot_data &lt;- plot_data[1:n_pcs,]\n  \n  # Plot\n  ggplot(plot_data, aes(x = factor(PC))) +\n    geom_bar(aes(y = Variance_Explained), stat = \"identity\", fill = \"#22A884FF\") +\n    geom_line(aes(y = Cumulative_Explained, group = 1), color = \"#2A788EFF\", linewidth = 1) +\n    geom_point(aes(y = Cumulative_Explained), color = \"#2A788EFF\", size = 2) +\n    scale_y_continuous(\n      name = \"Fraction of Variance Explained\",\n      sec.axis = sec_axis(~., name = \"Cumulative Explained Variance\"),\n      expand = c(0,0)\n    ) +\n    labs(\n      title = \"Scree Plot\",\n      x = \"Principal Component\",\n      y = \"Fraction of Variance\"\n    ) +\n    default_theme()\n  \n}\n\n# Now calculate the PCs and plot\ncpm &lt;- cpm(y_filtered, log = TRUE)\npca &lt;- prcomp(t(cpm), scale. = TRUE)\n\nFirst we can see how much variation is explained by the PCs using a scree plot. For example, we can see that the first 3 PCs already explain almost 60% of the variance, and after each PCs doesn’t add too much to the variance. That means that if we see a variable having an effect in the first 3 PCs, it is probably a good idea to correct for that during the testing.\n\nplotScree(pca, n_pcs = 20)\n\n\n\n\n\n\n\n\nHere you can see that the samples from controls (CTRL) and treated celiac disease (TCD) tend to cluster together and separated from the untreated celiac disease (UCD).\n\n# Plot the first 2 PCs colored by the condition\nplotPC(pca,\n      coldata = y_filtered$samples,\n      coord_1 = 'PC1',\n      coord_2 = 'PC2',\n      color_by = 'condition')\n\n\n\n\n\n\n\n\nHere you can see that the samples from controls (CTRL) and treated celiac disease (TCD) tend to cluster together and separated from the untreated celiac disease (UCD). You can plot any other PCs and grouping variable you want to explore how that variable influences the data, for example, batch of sequencing that seems to be a significant source of variation:\n\nplotPC(pca,\n      coldata = y_filtered$samples,\n      coord_1 = 'PC1',\n      coord_2 = 'PC2',\n      color_by = 'batch.of.sequencing')\n\n\n\n\n\n\n\n\n\n\nNormalization of read counts\nIn order to properly perform certain downstream analysis, such as principal component analysis (PCA), or clustering, we need to properly normalize the counts. This step adjusts the raw counts to account for technical variations that can mask true biological differences. These factors are things like sequencing depth, library sizes, gene length, and GC content. In edgeR, we normalize the counts using the trimmed mean M-values (TMM) method with the function normLibSizes\n\ny_filtered &lt;- calcNormFactors(y_filtered)\n\n\n\nVariance partition analysis (optional)\nAlternatively to the PCA, you can use a “Variance Partition analysis” to quantify and interpret the sources of biological and technical variation in your data. This uses the package variancePartition. This uses the TMM normalized counts and a formula with the variables from your metadata you want to check (more on models and formulas will be explained in future steps). You can investigate any variables you want at once here, instead of one by one as you would do in the PCA.\n\n# First we assess correlation between all pairs of variables\nform &lt;- ~ condition + sex + age + batch.of.RNA.isolation + batch.of.sequencing + RNA.concentration + RIN.score + lib.size + cell.counts + H..pylori + marsh.score\nC &lt;- canCorPairs(form, y_filtered$samples)\n\nWarning in canCorPairs(form, y_filtered$samples): Regression model may be problematic.\nHigh colinearity between variables:\n  condition and marsh.score\n\nplotCorrMatrix(C)\n\n\n\n\n\n\n\n\nWe see from this plot that GC content, RIN score, batch of isolation and batch of sequencing are all strongly correlated, so we don’t want to include all of them in our model. Because batch of sequencing was also important in the PCA, let’s use just that one.\nNow we are going to fit a model in the gene expression data to check how much each variable contributes to the variation, you can choose which variables to include based on the previous plot.\n\ndesign &lt;- model.matrix(~condition, y_filtered$samples)\nv &lt;- voom(y_filtered, design)\n\n# We need to scale some variables so they are all in the same scale and comparable\ny_filtered$samples$age &lt;- scale(y_filtered$samples$age)\ny_filtered$samples$lib.size_scaled &lt;- scale(y_filtered$samples$lib.size)\ny_filtered$samples$cell.counts_scaled &lt;- scale(y_filtered$samples$cell.counts)\n\n# Categorical variables need to be specified with (1|variable)\nform &lt;- ~ (1|condition) + (1|sex) + (1|batch.of.sequencing) + (1|H..pylori) + (1|marsh.score) + age + RNA.concentration + lib.size_scaled + cell.counts_scaled\nvarPart &lt;- fitExtractVarPartModel(v, form, y_filtered$samples)\n\nWarning: \nVariables contain NA's: H..pylori, age \nSamples with missing data will be dropped.\n\n\nWarning in .fitExtractVarPartModel(exprObj, formula, data, REML = REML, : Model failed for 2 responses.\n  See errors with attr(., 'errors')\n\nplotVarPart(varPart)\n\n\n\n\n\n\n\n\nIn this plot, we can see how much each variable contributes to the variance in the data (the model is fit for every gene, that’s why you see a distribution). Quite some variance is explained by condition (and therefore also Marsh score, a measure of inflammation in CeD), as you would expect. Batch of sequencing, sex, age, and RNA concentration are all also some significant sources of variation that we could include in the model. However, we see that there is still a lot of variance left in the residuals - that means variance that is not being captured by any of the other variables in the model. This can happen for many reasons that we won’t go into details here, but keep in mind that ideally you want a model where most of variance is explained by the variables in the model and you don’t have much left in the residuals."
  },
  {
    "objectID": "Bulk_RNAseq_Tutorial.html#differential-expression-analysis",
    "href": "Bulk_RNAseq_Tutorial.html#differential-expression-analysis",
    "title": "Bulk RNA-seq data analysis tutorial",
    "section": "Differential expression analysis",
    "text": "Differential expression analysis\nThe definition of a differential expressed gene (DEG) usually depends on whether or not a particular gene is significantly (p-value = 0.05, after multiple testing correction) over or under expressed when compared to another class (can be different treatment, control, tissue etc,). Nevertheless, we can be a bit more strict in this definition, we could require either a lower p-value (such as 0.01, or 0.001), and require a certain difference of expression between the two conditions, this difference between two conditions can be interpreted as the log2 fold change: \\(log2FC = log2 (mean expression condition 1 /mean expression condition 2)\\)\nNow that we have looked at the data and seen what things may affect the expression of genes in there, we can start making a design matrix to do differential expression analysis. A design matrix is a table that represents your experimental setup in a mathematical form. It tells a statistical model which samples belong to which experimental groups, such as “diseased” vs. “healthy” and also how other variables (such as sex, age, etc.) affect the sample. For a more detailed explanation on how to design matrices for many types of experimental designs, check this guide.\n\nBuilding a design matrix\nThe first thing in you want to include in your design is of course the variable you are more interested on, for example here we want to find the genes that are differentially expressed because of condition . Next, you want to include your covariates: the variables that we identified above that influence the data but are not the object of our investigation, so we correct for them. You can write the formula for the design matrix in two ways - with or without intercept - and to do that we use the function model.matrix and a formula, which always starts with a ~ followed by your variables, for example ~ condition + sex + age.\n\nModel with intercept\nLet’s use a simple example where we are modeling the effect of group (disease or control), the design matrix can be created with model.matrix(~group). This creates a model with intercept. The intercept is the reference level for group, in this case, “control”. In this case, gene expression is modeled as Y ~ a + Xb, where Y is the expression, a is the intercept, X is 0 (control) or 1 (disease), and b represents how much the expression changes from the reference group. . When X = 0, Y = a, the expression for control. When X = 1, Y = a + b, the expression for disease. Below is a visual representation of how to interpret this.\n\n\n\nModel without intercept\nA design matrix without intercept is coded as model.matrix(~0+group). This model is essentially the same as before, however now you have a term associated with group control and a term associated with group disease: Y ~ aX1 + bX2, where X1 is 1 for control and 0 for disease and X2 is 1 for disease and 0 for control.\n\nThe result you get from both models is the same, but for experimental designs with more than 2 groups (like our data) and other complex designs, is easier to work with the model without intercept. That is because having one term for each group allows you to easily define the contrasts for exactly what you want to test and find the DEGs for.\n\n\n\nDefining a contrast matrix\nNow that we have a model for the gene expression, we want to find the difference between the mean expression of the groups of interest. The difference in parameter estimates can be calculated using a contrast matrix via the makeContrast function. To specify your comparison of interest, use the columns from the design matrix, for example:\n## DO NOT RUN ##\ndesign &lt;- model.matrix(0+group)\nmakeContrasts(groupSICK - groupHEALTHY, levels = colnames(design))\nThis will create the contrast to find the DEGs in sick vs healthy that we will use in the following steps. Note that this is only applicable when creating a design matrix without intercept. Back to our data, this is how we will define our design matrix and contrasts, including the covariates:\n\n# Here it is also important that the categorial variables are factors and the numerical variables are on the same scale\ny_filtered$samples$condition &lt;- factor(y_filtered$samples$condition, levels = c('CTRL', 'TCD', 'UCD'))\ny_filtered$samples$batch.of.sequencing &lt;- factor(y_filtered$samples$batch.of.sequencing)\ny_filtered$samples$sex &lt;- factor(y_filtered$samples$sex)\ny_filtered$samples$RNA.concentration &lt;- scale(y_filtered$samples$RNA.concentration)\n\n# The parameter data in model.matrix() is your metadata (y$samples)\ndesign &lt;- model.matrix(~ 0 + condition + batch.of.sequencing + sex + RNA.concentration, data = y_filtered$samples)\nhead(design)\n\n     conditionCTRL conditionTCD conditionUCD batch.of.sequencingB sexM\nCON1             1            0            0                    0    1\nCON2             1            0            0                    0    1\nCON3             1            0            0                    0    0\nCON4             1            0            0                    0    0\nCON5             1            0            0                    0    1\nCON6             1            0            0                    0    1\n     RNA.concentration\nCON1        -0.7021056\nCON2        -0.4025453\nCON3        -0.6073147\nCON4        -0.5172371\nCON5        -0.1783988\nCON6        -0.6052199\n\n\nNow we specify the comparisons we want to make. There are many possible combinations we can investigate here, for example: untreated celiac disease vs control, untreated celiac disease vs treated celiac disease, and so on… When working on your own analysis think about the biological questions you want to answer and define the contrasts accordingly.\n\ncontrasts_matrix &lt;- makeContrasts(\n    UCDvsCTRL = conditionUCD - conditionCTRL,\n    TCDvsCTRL = conditionTCD - conditionCTRL,\n    UCDvsTCD = conditionUCD - conditionTCD,\n    levels = colnames(design)\n)\nhead(contrasts_matrix)\n\n                      Contrasts\nLevels                 UCDvsCTRL TCDvsCTRL UCDvsTCD\n  conditionCTRL               -1        -1        0\n  conditionTCD                 0         1       -1\n  conditionUCD                 1         0        1\n  batch.of.sequencingB         0         0        0\n  sexM                         0         0        0\n  RNA.concentration            0         0        0\n\n\nNow that we have our models and contrasts, we are finally ready to find the DEGs.\n\n\nFit the model and find DEGs\nIn the following steps we perform the necessary steps to fit the model and extract the DEGs for the comparisons we want. The function voom transforms the raw counts and stabilized variance, so the data can be modeled with limma’s linear model.\n\nv &lt;- voom(y_filtered, design, plot=TRUE) # change to FALSE if you don't want the plot\n\n\n\n\n\n\n\n\nThe plot generated by voom is a diagnostic tool that visualizes the relationship between a gene’s average expression and its variance. The plot above is a example of a good plot: it has a “smooth”, downward-sloping trend line, showing that voom has captured the mean-variance relationship. A bad plot usually has “peaks” and looks irregular, suggesting there is a problem with the data, such as bad filtering of lowly expressed genes or technical issues.\nNow we fit the model to the voom-transformed data and extract the results.\n\n# Fit the model\nfit &lt;- lmFit(v, design)\nfit2 &lt;- contrasts.fit(fit, contrasts_matrix[, \"UCDvsCTRL\"]) # here is where you specify the contrast you want the results for\nfit2 &lt;- eBayes(fit2)\n\n# Get the table with results\nres &lt;- topTable(fit2, sort.by = \"P\", n = Inf) # this returns the table with the results for all the genes, ordered by p-value\nknitr::kable(head(res))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngenes\nlogFC\nAveExpr\nt\nP.Value\nadj.P.Val\nB\n\n\n\n\nENSG00000117228\nENSG00000117228\n1.9855499\n6.367871\n13.50997\n0\n0\n40.64992\n\n\nENSG00000092010\nENSG00000092010\n0.7266291\n7.670674\n12.78049\n0\n0\n37.62139\n\n\nENSG00000204264\nENSG00000204264\n1.1348134\n6.870195\n12.75139\n0\n0\n37.49876\n\n\nENSG00000148773\nENSG00000148773\n2.7271550\n6.506489\n12.70288\n0\n0\n37.28963\n\n\nENSG00000182054\nENSG00000182054\n1.7045698\n6.584646\n12.47710\n0\n0\n36.33895\n\n\nENSG00000182481\nENSG00000182481\n2.0288446\n4.891909\n12.29831\n0\n0\n35.47388\n\n\n\n\n\nThese are the results for just untreated celiac disease vs control. Instead of running the code above multiple times for each comparison, we can do this iterative for all comparisons.\n\nres_all &lt;- list()\nfor (x in colnames(contrasts_matrix)) {\n  \n  contr &lt;- contrasts_matrix[, x]\n  \n  fit2 &lt;- contrasts.fit(fit, contr)\n  fit2 &lt;- eBayes(fit2)\n  res &lt;- topTable(fit2, sort.by = \"P\", n = Inf)\n  res$Contrast &lt;- x\n  res_all &lt;- append(res_all, list(res))\n    \n}\nresults &lt;- list_rbind(res_all)\nknitr::kable(head(results))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngenes\nlogFC\nAveExpr\nt\nP.Value\nadj.P.Val\nB\nContrast\n\n\n\n\nENSG00000117228…1\nENSG00000117228\n1.9855499\n6.367871\n13.50997\n0\n0\n40.64992\nUCDvsCTRL\n\n\nENSG00000092010…2\nENSG00000092010\n0.7266291\n7.670674\n12.78049\n0\n0\n37.62139\nUCDvsCTRL\n\n\nENSG00000204264…3\nENSG00000204264\n1.1348134\n6.870195\n12.75139\n0\n0\n37.49876\nUCDvsCTRL\n\n\nENSG00000148773…4\nENSG00000148773\n2.7271550\n6.506489\n12.70288\n0\n0\n37.28963\nUCDvsCTRL\n\n\nENSG00000182054…5\nENSG00000182054\n1.7045698\n6.584646\n12.47710\n0\n0\n36.33895\nUCDvsCTRL\n\n\nENSG00000182481…6\nENSG00000182481\n2.0288446\n4.891909\n12.29831\n0\n0\n35.47388\nUCDvsCTRL\n\n\n\n\n\nThis list have the genes with their Ensembl ID, to help with interpretation we will add the gene symbol and entrezid annotation before we continue.\n\nmart &lt;- useEnsembl(biomart = \"ensembl\", dataset = \"hsapiens_gene_ensembl\")\ngenemap &lt;- getBM(attributes = c(\"ensembl_gene_id\", \"hgnc_symbol\", \"entrezgene_id\"),\n                 filters = \"ensembl_gene_id\",\n                 values = unique(results$genes),\n                 mart = mart)\n                        \nresults &lt;- left_join(results, genemap, by = join_by(\"genes\" == \"ensembl_gene_id\"), relationship = 'many-to-many')\nknitr::kable(head(results))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngenes\nlogFC\nAveExpr\nt\nP.Value\nadj.P.Val\nB\nContrast\nhgnc_symbol\nentrezgene_id\n\n\n\n\nENSG00000117228\n1.9855499\n6.367871\n13.50997\n0\n0\n40.64992\nUCDvsCTRL\nGBP1\n2633\n\n\nENSG00000092010\n0.7266291\n7.670674\n12.78049\n0\n0\n37.62139\nUCDvsCTRL\nPSME1\n5720\n\n\nENSG00000204264\n1.1348134\n6.870195\n12.75139\n0\n0\n37.49876\nUCDvsCTRL\nPSMB8\n5696\n\n\nENSG00000148773\n2.7271550\n6.506489\n12.70288\n0\n0\n37.28963\nUCDvsCTRL\nMKI67\n4288\n\n\nENSG00000182054\n1.7045698\n6.584646\n12.47710\n0\n0\n36.33895\nUCDvsCTRL\nIDH2\n3418\n\n\nENSG00000182481\n2.0288446\n4.891909\n12.29831\n0\n0\n35.47388\nUCDvsCTRL\nKPNA2\n3838\n\n\n\n\n\nWe can also create a dataframe containing only the significant results. Here we are considering significant the genes with absolute log2FC &gt; 1 and adjusted p-value &lt; 0.05.\n\nresults_significant &lt;- results |&gt;\n    dplyr::filter(abs(logFC &gt; 1) & adj.P.Val &lt; 0.05)\n\n# Save the results\n# Specify the path to the folder you want to save the results\nfolder_path &lt;- \"results\"\n\n# Check if the folder exists\nif (!dir.exists(folder_path)) {\n  # If it doesn't exist, create it\n  dir.create(folder_path)\n  cat(paste0(\"Folder '\", folder_path, \"' created successfully!\\n\"))\n} else {\n  cat(paste0(\"Folder '\", folder_path, \"' already exists.\\n\"))\n}\n\nFolder 'results' already exists.\n\nwrite.csv(results, paste0(folder_path, \"/DEG_results_biopsies_oslo.csv\"), row.names=F)\nwrite.csv(results_significant, paste0(folder_path, \"/DEG_results_biopsies_oslo_significant_only.csv\"), row.names=F)"
  },
  {
    "objectID": "Bulk_RNAseq_Tutorial.html#visualization",
    "href": "Bulk_RNAseq_Tutorial.html#visualization",
    "title": "Bulk RNA-seq data analysis tutorial",
    "section": "Visualization",
    "text": "Visualization\n\nVolcano plot\nNow we can visualize the DEGs in a volcano plot, which plots the -log10(padj) against the fold change of the genes. This allows for easy identification of data points that show both significant changes and large magnitudes of change.\n\n# Define a function to make a volcano plot\n# Makes a volcano plot, highlighting the genes above the specified log2FC threshold and labels the top n genes (based on padj)\nVolcanoPlot &lt;- function(res, threshold = 0.5, p_cutoff = 0.05, n_labels = 15, title = '') {\n    # Prepare the data\n  res_plot &lt;- res |&gt;\n    mutate(DE = case_when(\n      adj.P.Val &lt; p_cutoff & logFC &gt;= threshold ~ 'upregulated',\n      adj.P.Val &lt; p_cutoff & logFC &lt;= -threshold ~ 'downregulated',\n      adj.P.Val &gt;= p_cutoff | abs(logFC) &lt; threshold ~ 'not DE'\n    ))\n  \n  # Add label to the top n genes (ranked by FC)\n  n &lt;- n_labels\n  \n  top_genes &lt;- res_plot |&gt; dplyr::filter(DE != 'not DE') |&gt; \n    group_by(sign(logFC)) |&gt; \n    top_n(n_labels, -log10(adj.P.Val)) |&gt; \n    pull(hgnc_symbol)\n  res_plot$genelabel &lt;- ''\n  res_plot$genelabel[res_plot$hgnc_symbol %in% top_genes] &lt;- res_plot$hgnc_symbol[res_plot$hgnc_symbol %in% top_genes]\n  \n  color_map &lt;- c(\"not DE\" = \"gray\", \"downregulated\" = \"#2166ac\", \"upregulated\" = \"#b2182b\")\n  \n  ggplot(res_plot, aes(x = logFC, y = -log10(adj.P.Val))) +\n    geom_point(aes(colour = DE), size = 1.5) +\n    geom_text_repel(aes(label = genelabel), min.segment.length = 0.25, force = 10) +\n    geom_hline(yintercept = -log10(p_cutoff), colour = '#696969', linetype = 'dashed') +\n    geom_vline(xintercept = -threshold, colour = '#696969', linetype = 'dashed') +\n    geom_vline(xintercept = threshold, colour = '#696969', linetype = 'dashed') +\n    scale_color_manual('', values = color_map) +\n    default_theme() +\n    theme(legend.text = element_text(size = rel(1.25))) +\n    labs(title = title,\n         x = 'log2 fold change',\n         y = '-log10 adjusted p-value')\n  \n}\n\nLike before, we do this in a iterative way to make the volcano plots for all comparisons at the same time. You can change the log2FC threshold or the p_cutoff based on your cut-offs for a gene to be considered DE.\n\nvolcanos &lt;- list()\nfor(c in unique(results$Contrast)) {\n    data &lt;- dplyr::filter(results, Contrast == c)\n    p &lt;- VolcanoPlot(data, threshold = 0.5, p_cutoff = 0.05, n_labels = 15, title = c)\n    volcanos &lt;- append(volcanos, list(p))\n}\nwrap_plots(volcanos, guides = 'collect')\n\n\n\n\n\n\n\n\n\n\nHeatmap\nWe can also visualize the DEGs in a heatmap. Heatmaps are color coded, graphical representations of a matrix. The rows and columns of this matrix can be arranged in a certain way to showcase the similarities between columns and rows. This arrangement of columns and rows can be used an unsupervised approach such as hierarchical clustering, which can be useful to find patterns in the data, such as cluster of genes that are down/up-regulated with similar magnitude. It is also useful to visualize the gene expression per sample. To create this plot we use the expression data as logCPM from the significant genes.\n\n# Choose a contrast to visualize\ncontrast &lt;- 'UCDvsCTRL'\n\n# Get the DEGs for this contrast\nde_genes &lt;- results_significant$genes[results_significant$Contrast == contrast]\n\n# Get the logCPM counts for these genes\ncpm_de &lt;- cpm(y_filtered, log = TRUE)\ncpm_de &lt;- cpm_de[de_genes,]\n\n# Calculates z-score\nz &lt;- t(scale(t(cpm_de)))\n\n# Create annotation dataframe for the heatmap - this can be whatever you want to show about the samples (columns)\nannotation_col &lt;- y_filtered$samples[colnames(z), c('condition', 'marsh.score')]\nrownames(annotation_col) &lt;- y_filtered$samples[colnames(z), 'sample']\nann_colors &lt;- list(\n    condition = c('CTRL' = '#29d3d6',\n                 'TCD' = '#29d62e',\n                 'UCD' = '#910a0a'),\n    marsh.score = c('n.m.' = '#FEE5D9',\n                   '0' = '#FCAE91',\n                   '1' = '#FB6A4A',\n                   '2' = '#DE2D26',\n                   '3' = '#A50F15'))\n\n# Make the heatmap with values scaled by row (genes), so you can compare between samples (columns)\npheatmap(z, cluster_rows = T, show_rownames = F, show_colnames = F, border_color = NA,\n        color = colorRampPalette(rev(brewer.pal(n = 7, name = \"RdBu\")))(100),\n        annotation_col = annotation_col,\n        annotation_colors = ann_colors,\n        treeheight_col = FALSE)\n\n\n\n\n\n\n\n\n\n\nData points\nIn some cases it’s also useful to visualize the expression values for certain genes across all samples. Lets check for the top 10 DEGs between untreated celiacs and controls. Remember, in order to properly compare expression values across samples we need to use the normalized levels (in this case logCPM).\n\n# Select the top 10 genes (based on adj p-val) for UCDvsCTRL\ntop10_genes &lt;- results_significant |&gt;\n    dplyr::filter(Contrast == 'UCDvsCTRL') |&gt;\n    top_n(-10, adj.P.Val)\n\n# Get the cpm counts\ntop10_cpm &lt;- cpm(y_filtered, log=TRUE)\ntop10_cpm &lt;- as.data.frame(cpm[top10_genes$genes,])\ntop10_cpm$symbol &lt;- top10_genes$hgnc_symbol # add the gene symbol\n\n# Reshape the data so we can plot\ndata_plot &lt;- melt(top10_cpm)\n\nUsing symbol as id variables\n\n# Add sample information (condition)\ndata_plot &lt;- left_join(data_plot, y_filtered$samples[, c('sample', 'condition')], by = join_by(\"variable\" == \"sample\"))\n\ntop10_Plot &lt;- ggplot(data_plot, aes(x = condition, y = value))+\n                geom_jitter(alpha=0.8)+\n                geom_boxplot(alpha=0.6)+\n                facet_grid(~symbol, scale=\"free\")+\n                ylab(\"logCPM\")+\n                xlab(\"\")+\n                default_theme()+\n                theme(axis.text.x = element_text(angle=45, hjust = 1))\ntop10_Plot\n\n\n\n\n\n\n\n\nNow we have our DEGs and many ways to visualize them. But what do they do? How are they biologically relevant?\nMost of the times we have hundreds or thousands of DEGs, so it might be hard to look at them individually and check their function. To deal with that, we can do a pathway analysis to find if the DEGs are involved in common pathways that are enriched in the results."
  },
  {
    "objectID": "Bulk_RNAseq_Tutorial.html#pathway-analysis",
    "href": "Bulk_RNAseq_Tutorial.html#pathway-analysis",
    "title": "Bulk RNA-seq data analysis tutorial",
    "section": "Pathway analysis",
    "text": "Pathway analysis\nTo find if our DEGs are enriched for a particular biological function we can use a Over Representation Analysis (ORA) or a Gene Set Enrichment Analysis (GSEA). ORA is a method to find if known biological functions are over-represented in a given list of genes (e.g. DEGs), comparing to a background of all genes measures. A limitation of this method is that it doesn’t take into account how much the expression of a gene changes (i.e. the log2 fold-change). GSEA, on the other hand, uses the log2 fold-change information to rank all genes and calculate an enrichment score that reflects how clustered the genes from a particular set are at the top (upregulated) or bottom (downregulated) of the ranked list. There are many tools and databases with gene biological function that you can use, in this tutorial we will use the package clusterProfiler and the databases gene ontology, KEGG, and Reactome.\n\nPrepare the data\nLoad the results from the DE analysis. Here let’s use all genes that are significant (adj. p-value &lt; 0.05) but without filtering for the fold-change, so we can see how the results from ORA and GSEA will differ from each other. In your own analysis, you can set a fold-change cut-off as well if necessary. Besides, we need the Entrezid for most of the methods so we will filter out genes that don’t have one.\n\n# Load the results and keep only the significant genes and remove genes without entrezid\nresults &lt;- read.csv('results/DEG_results_biopsies_oslo.csv')\nresults_sig &lt;- results |&gt; \n    filter(adj.P.Val &lt; 0.05 & !is.na(entrezgene_id))\n\n\n\nOver Representation Analysis\nThe function compareCluster allows us to run ORA for the three comparisons and two directions (up or downregulated) at the same time. The function needs a formula specifying how you want to run the comparison. To tell we want the analysis per contrast and for each direction in that contrast we use the formula entrezgene_id ~ Contrast + direction. In this analysis, you can also specify a “universe”: a list of all genes that were tested in your analysis, to be used as a background. (This block of code might take a few minutes to run.)\n\n# Create a column with direction of DE\nresults_sig$direction &lt;- if_else(results_sig$logFC &gt; 0, \"upregulated\", \"downregulated\")\n\n# Get the universe - all genes tested\nuniverse &lt;- results |&gt; filter(!is.na(entrezgene_id)) |&gt; pull(entrezgene_id)\n\n# Run ORA using gene ontology biological process\nora_go &lt;- compareCluster(entrezgene_id ~ Contrast + direction,\n                        fun = 'enrichGO',\n                        universe = universe,\n                        ont = \"BP\",\n                        OrgDb = org.Hs.eg.db,\n                        data = results_sig,\n                        pvalueCutoff = 0.05,\n                        readable = TRUE)\n\n# Run ORA using KEGG Pathway\nora_kegg &lt;- compareCluster(entrezgene_id ~ Contrast + direction,\n                        fun = 'enrichKEGG',\n                        universe = universe,\n                        organism = \"hsa\",\n                        data = results_sig,\n                        pvalueCutoff = 0.05)\n\n# Run ORA using Reactome\nora_reactome &lt;- compareCluster(entrezgene_id ~ Contrast + direction,\n                        fun = 'enrichPathway',\n                        universe = universe,\n                        organism = \"human\",\n                        data = results_sig,\n                        pvalueCutoff = 0.05,\n                        readable = TRUE)\n\nThese objects contain a lot of information about the test and results. You can access the table with results with @compareClusterResult, for example:\n\nknitr::kable(head(ora_go@compareClusterResult))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCluster\nContrast\ndirection\nID\nDescription\nGeneRatio\nBgRatio\nRichFactor\nFoldEnrichment\nzScore\npvalue\np.adjust\nqvalue\ngeneID\nCount\n\n\n\n\nUCDvsCTRL.downregulated\nUCDvsCTRL\ndownregulated\nGO:0006631\nfatty acid metabolic process\n106/1700\n405/18986\n0.2617284\n2.923044\n12.267746\n0\n0\n0\nPCK1/ACAT1/ACADM/CYP3A4/CYP2J2/LPIN2/LIPA/ABHD6/CD36/EPHX1/CYP2C9/ASAH2/ABHD2/HACL1/ACSF2/PRKAB2/CYP4F2/ECHDC2/GPX4/RGN/APPL2/CYP4V2/ACOX1/APOA4/ACBD4/NAAA/PTGR1/APOC3/HADHB/ACAA1/MLXIPL/PDK4/DEGS1/NR1H3/CYP2D6/CYP4F12/BDH2/CROT/CRAT/CRYL1/HPGD/PCK2/PDK2/ACBD5/ACSS1/ABCD4/ACSL5/PHYH/GSTM2/PPARA/HACD2/KAT2B/CES2/SLC27A4/ACADSB/GGT1/ETFDH/FABP2/SIRT2/CYP2S1/CYP2C18/ACOX2/ACAA2/ABHD5/UGT1A10/ABHD12/CYP2C19/ASAH1/CYP4F3/ADH4/SGPL1/INSIG2/ACADVL/CEACAM1/WDTC1/PPARG/LPGAT1/PRKAG2/SCP2/UBR4/DCAF5/ABCD1/ALOX5/SESN2/HPGDS/PDK3/PTGS1/AIG1/ALDH3A2/ALOX5AP/SCAP/ACOT11/CBR1/HADHA/TNFRSF1A/LPIN3/NR1H2/ABCD3/PEX5/ACSL1/CPT2/SREBF1/MGLL/AUH/ACADS/MGST3\n106\n\n\nUCDvsCTRL.downregulated\nUCDvsCTRL\ndownregulated\nGO:0046486\nglycerolipid metabolic process\n96/1700\n385/18986\n0.2493506\n2.784807\n11.095220\n0\n0\n0\nPCK1/APOA1/LPIN2/LIPA/APOB/ABHD6/ABHD2/SERINC1/SORL1/SCARB1/RGN/APOA4/NAAA/DGAT2/DGKA/ENPP2/APOC3/GK/DGAT1/LPCAT3/DDHD2/NR1H3/AGPAT3/PIP4K2A/PCK2/PDGFA/G6PC1/PLCH2/PIP4P1/MTMR11/MTMR4/MTMR3/TTC7A/GPAM/CIDEC/GPD1/INPP5K/GPAT3/ABHD5/CDIPT/PIK3R5/ABHD12/PI4K2B/SLC44A4/APOBEC1/MBOAT7/INSIG2/GK5/PNPLA2/LPGAT1/PIKFYVE/CAT/AVIL/PI4KA/PAFAH1B1/MTTP/PGS1/PIP5K1C/CDK8/BMX/PI4KB/PLCG2/MOGAT2/AADAC/HYCC2/MECP2/GPCPD1/CHKA/CEPT1/TAFAZZIN/PIP5K1B/ABHD4/MTMR12/HADHA/PGAP3/MOGAT3/LPIN3/PCYT1A/INPP5J/IPMK/PISD/NR1H2/PIK3CG/ACSL1/PNPLA6/SREBF1/PRDX6/MGLL/CDS2/INPP4A/SLC44A2/PCYT2/MTMR10/PLCB2/PLCG1/INPP5B\n96\n\n\nUCDvsCTRL.downregulated\nUCDvsCTRL\ndownregulated\nGO:0044242\ncellular lipid catabolic process\n71/1700\n238/18986\n0.2983193\n3.331700\n11.351840\n0\n0\n0\nPCK1/ACAT1/ACADM/LPIN2/APOB/ABHD6/ASAH2/ABHD2/HACL1/SORL1/SCARB1/CYP4F2/ECHDC2/ACOX1/APOA4/LCT/ENPP2/APOC3/HADHB/ACAA1/DDHD2/ENPP7/GALC/CYP4F12/BDH2/NEU1/CROT/CRAT/PCK2/GBA3/ABCD4/SMPD1/FUCA1/PHYH/PPARA/SLC27A4/AKR1B10/ETFDH/SIRT2/ACOX2/SMPD3/ACAA2/ABHD5/PRKCD/ABHD12/ASAH1/CYP4F3/SGPL1/ACADVL/ALDH3B1/PNPLA2/SCP2/ABCD1/SESN2/AIG1/PLCG2/AADAC/GPCPD1/NAGA/HADHA/LPIN3/ABCD3/PIK3CG/PEX5/CPT2/PNPLA6/PRDX6/MGLL/AUH/ACADS/PLCG1\n71\n\n\nUCDvsCTRL.downregulated\nUCDvsCTRL\ndownregulated\nGO:0016042\nlipid catabolic process\n89/1700\n351/18986\n0.2535613\n2.831832\n10.863179\n0\n0\n0\nPCK1/ACAT1/ACADM/CYP3A4/LPIN2/LIPA/APOB/ABHD6/ASAH2/ABHD2/HACL1/SORL1/SCARB1/CYP4F2/ECHDC2/ACOX1/APOA4/HSD17B11/NAAA/LCT/ENPP2/APOC3/HADHB/ACAA1/DPEP1/ABHD15/DDHD2/ENPP7/GALC/CYP4F12/BDH2/NEU1/CROT/CRAT/HPGD/PCK2/GBA3/PLCH2/ABCD4/SMPD1/FUCA1/PHYH/PPARA/SLC27A4/AKR1B10/ETFDH/SIRT2/CIDEC/ACOX2/SULT2A1/SMPD3/ACAA2/ABHD5/PLA2G12B/PRKCD/ABHD12/ASAH1/CYP4F3/SGPL1/ACADVL/ALDH3B1/PNPLA2/SCP2/PAFAH1B1/ABCD1/SESN2/THRA/AIG1/CYP27A1/PLCG2/AADAC/GPCPD1/NAGA/ABHD4/HADHA/SCT/LPIN3/CRTC3/ABCD3/PIK3CG/PEX5/CPT2/PNPLA6/PRDX6/MGLL/AUH/ACADS/PLCB2/PLCG1\n89\n\n\nUCDvsCTRL.downregulated\nUCDvsCTRL\ndownregulated\nGO:0044282\nsmall molecule catabolic process\n83/1700\n375/18986\n0.2213333\n2.471903\n9.028018\n0\n0\n0\nPCK1/ALDOB/ACAT1/ACADM/CYP3A4/LPIN2/SORD/ABHD2/HACL1/SCARB1/OAT/CYP4F2/ECHDC2/SULT1B1/PRODH/ACOX1/GDA/GK/HADHB/ACAA1/DPEP1/IDS/QPRT/CYP4F12/BDH2/CROT/CRAT/ENPP4/CRYL1/SLC25A44/SHMT1/PCK2/GLS/ACSS1/ABCD4/GNPDA1/HGD/PHYH/PPARA/SLC27A4/ACADSB/AKR1B10/SULT1A2/ETFDH/DERA/ACOX2/SULT2A1/ACAA2/CYP4F3/ADH4/ACADVL/ALDH3B1/ADA2/GK5/DLST/HAGH/ADA/SCP2/ABCD1/ENTPD7/ABAT/SESN2/IDNK/DPYD/AIG1/CYP27A1/ENTPD4/NAGK/HADHA/LPIN3/HMGCL/PPM1K/ABCD3/RBKS/PEX5/PGM1/SULT1A1/CPT2/GLUD1/AUH/ACADS/ALDH6A1/MGAT1\n83\n\n\nUCDvsCTRL.downregulated\nUCDvsCTRL\ndownregulated\nGO:0006639\nacylglycerol metabolic process\n44/1700\n135/18986\n0.3259259\n3.640017\n9.653593\n0\n0\n0\nPCK1/LPIN2/LIPA/APOB/ABHD6/ABHD2/SORL1/SCARB1/RGN/APOA4/DGAT2/DGKA/APOC3/GK/DGAT1/DDHD2/NR1H3/PCK2/G6PC1/GPAM/CIDEC/GPAT3/ABHD5/ABHD12/APOBEC1/MBOAT7/INSIG2/GK5/PNPLA2/LPGAT1/CAT/AVIL/MTTP/PGS1/CDK8/MOGAT2/AADAC/MOGAT3/LPIN3/NR1H2/PIK3CG/ACSL1/SREBF1/MGLL\n44\n\n\n\n\n\nYou can visualize the results in many different ways, check the documentation of this package to see all options. For simplicity, we will plot only the dot plot here but explore other ways to visualize in your own analysis.\n\ndotplot(ora_go) +\n    default_theme() +\n    theme(axis.text.x = element_text(angle=45, hjust = 1))\n\n\n\n\n\n\n\n\n\n\nGene Set Enrichment Analysis (GSEA)\nBecause GSEA uses the log2 fold-change to rank the genes, we first need to prepare this input vector with genes ordered based on their fold-change. In this case, we will not use compareCluster to do everything all at once, instead we will use a custom function to prepare the data and run the analysis. We don’t need the universe genes in this case.\n\n# Define the function to create the ranked gene list and run the analysis\nrun_gsea &lt;- function(data, contrast, database = c('GO-BP', 'KEGG', 'Reactome')) {\n\n  # Creates the ordered gene list for given contrast\n  foldchanges &lt;- data$logFC[data$Contrast == contrast]\n  names(foldchanges) &lt;- data$entrezgene_id[data$Contrast == contrast]\n  foldchanges &lt;- sort(foldchanges, decreasing = TRUE)\n\n  # Run the analysis for given database\n  if(database == 'GO-BP') {\n    res &lt;- gseGO(geneList = foldchanges, OrgDb = \"org.Hs.eg.db\", keyType = \"ENTREZID\", ont = \"BP\", pvalueCutoff = 0.05)\n  } else if(database == 'KEGG') {\n    res &lt;- gseKEGG(geneList = foldchanges, organism = 'hsa', pvalueCutoff = 0.05)\n  } else if(database == 'Reactome') {\n    res &lt;- gsePathway(geneList = foldchanges, organism = 'human', pvalueCutoff = 0.05)\n  } else {\n    print(\"Choose a database among GO-BP, KEGG or Reactome.\")\n  }\n  return(res)\n\n}\n\nNow apply the function to our contrasts. For simplicity, we will do only for GO-BP.\n\ngsea_ucd_ctrl &lt;- run_gsea(results_sig, contrast = 'UCDvsCTRL', database = 'GO-BP')\n\nusing 'fgsea' for GSEA analysis, please cite Korotkevich et al (2019).\n\n\npreparing geneSet collections...\n\n\nGSEA analysis...\n\n\nleading edge analysis...\n\n\ndone...\n\ngsea_ucd_tcd &lt;- run_gsea(results_sig, contrast = 'UCDvsTCD', database = 'GO-BP')\n\nusing 'fgsea' for GSEA analysis, please cite Korotkevich et al (2019).\n\n\npreparing geneSet collections...\n\n\nGSEA analysis...\n\n\nleading edge analysis...\n\n\ndone...\n\n# Converts entrezid back to symbol\ngsea_ucd_ctrl &lt;- setReadable(gsea_ucd_ctrl, org.Hs.eg.db)\ngsea_ucd_tcd &lt;- setReadable(gsea_ucd_tcd, org.Hs.eg.db)\n\nSimilarly to ORA, we can check the results with @result. Note a column called NES, this is the Normalized Enrichment Score and the most important metric here to interpret the results. The NES is derived from the enrichment score (ES), a value that reflects the degree to which a gene set is overrepresented at the top (upregulated, positive ES) or bottom (downregulated, negative ES) of a ranked gene list. This score is calculated by a “random walk” algorithm that increases a running sum when it encounters a gene from the set and decreases it otherwise. The final ES is the maximum deviation from zero during this walk.\n\nknitr::kable(head(gsea_ucd_ctrl))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nID\nDescription\nsetSize\nenrichmentScore\nNES\npvalue\np.adjust\nqvalue\nrank\nleading_edge\ncore_enrichment\n\n\n\n\nGO:0051276\nGO:0051276\nchromosome organization\n191\n0.5468616\n3.176649\n0\n0\n0\n984\ntags=57%, list=26%, signal=44%\nCDC20/TPX2/CCNB1/TOP2A/CENPE/KIF11/CENPF/NUSAP1/RACGAP1/HMGB3/HMGB2/REC8/MCM4/MYC/NDC1/SMC2/EZH2/TACC3/RCC1/SMC4/MCM3/PCNA/MCM5/KNTC1/KNL1/MCM7/CENPX/INCENP/RUVBL2/GNL3/HMGA1/NCAPD2/KIF22/CCT2/DKC1/RAN/ANAPC1/NASP/ERN2/PRKDC/NUP107/NCAPD3/MSH2/HSP90AA1/CCT5/LMNA/HSP90AB1/CCT3/MCM6/BANF1/NBN/PTGES3/TP53/HMGB1/SMARCC1/SSBP1/SMARCB1/NAT10/HNRNPC/HAT1/ACTL6A/NUP155/CCT7/RAD21/KPNB1/CCT6A/CDC27/BCCIP/XRCC6/TCP1/PARP1/CCT8/HNRNPA1/ITPA/XRCC5/CCT4/SMARCA4/PML/NOP10/HSPA1B/ATR/ACTB/HNRNPU/H3-3B/SUB1/KMT5A/PPP2R1A/DRG1/G3BP1/PHB2/STAG1/PBRM1/NUP133/RAB11A/NUDC/HNRNPA2B1/NUP62/MLH1/ASCC3/SMC1A/SEH1L/DHX9/DDX1/NAA50/HNRNPD/MCRS1/SMARCD2/CDK5RAP2/MCMBP\n\n\nGO:0007059\nGO:0007059\nchromosome segregation\n123\n0.5627398\n3.026897\n0\n0\n0\n265\ntags=26%, list=7%, signal=25%\nMKI67/CDC20/TPX2/ASPM/CCNB1/TOP2A/CENPE/KIF11/CENPF/NUSAP1/AURKA/RACGAP1/ECT2/REC8/GPSM2/NDC1/SMC2/TACC3/RCC1/SMC4/KNTC1/KNL1/CENPX/INCENP/NCAPD2/TUBB/KIF22/RAN/ANAPC1/RCC2/PLSCR1/NCAPD3\n\n\nGO:0098813\nGO:0098813\nnuclear chromosome segregation\n92\n0.5938188\n3.017546\n0\n0\n0\n265\ntags=29%, list=7%, signal=28%\nCDC20/TPX2/ASPM/CCNB1/TOP2A/CENPE/KIF11/CENPF/NUSAP1/AURKA/RACGAP1/ECT2/REC8/NDC1/SMC2/TACC3/RCC1/SMC4/KNTC1/KNL1/INCENP/NCAPD2/KIF22/RAN/ANAPC1/RCC2/NCAPD3\n\n\nGO:0033044\nGO:0033044\nregulation of chromosome organization\n93\n0.5742037\n2.928952\n0\n0\n0\n701\ntags=51%, list=19%, signal=42%\nCDC20/CCNB1/TOP2A/CENPE/CENPF/MYC/SMC2/TACC3/SMC4/KNTC1/KNL1/INCENP/RUVBL2/GNL3/NCAPD2/CCT2/DKC1/ANAPC1/NCAPD3/HSP90AA1/CCT5/LMNA/CCT3/NBN/PTGES3/TP53/SMARCC1/SMARCB1/NAT10/HNRNPC/ACTL6A/CCT7/RAD21/CCT6A/CDC27/TCP1/PARP1/CCT8/HNRNPA1/XRCC5/CCT4/SMARCA4/PML/ATR/ACTB/HNRNPU/H3-3B\n\n\nGO:0051301\nGO:0051301\ncell division\n179\n0.4964854\n2.896142\n0\n0\n0\n265\ntags=23%, list=7%, signal=22%\nCEP55/IQGAP3/CDC20/TPX2/ASPM/CCNB1/TOP2A/CENPE/KIF11/CENPF/CCNA2/NUSAP1/STMN1/AURKA/RACGAP1/ECT2/GPSM2/MYC/KIF20B/CDC25B/TIMELESS/SMC2/TACC3/CCND1/RCC1/SMC4/KNTC1/KNL1/CENPX/INCENP/CKAP2/GNL3/NCAPD2/TUBB/CKAP5/RAN/ANAPC1/RCC2/KAT2A/CDK2AP2/NCAPD3\n\n\nGO:0000819\nGO:0000819\nsister chromatid segregation\n72\n0.5863184\n2.858899\n0\n0\n0\n924\ntags=58%, list=25%, signal=45%\nCDC20/TPX2/CCNB1/TOP2A/CENPE/KIF11/CENPF/NUSAP1/RACGAP1/SMC2/TACC3/RCC1/SMC4/KNTC1/KNL1/INCENP/NCAPD2/KIF22/RAN/ANAPC1/NCAPD3/SMARCC1/SMARCB1/ACTL6A/RAD21/KPNB1/CDC27/BCCIP/SMARCA4/HSPA1B/ACTB/HNRNPU/KMT5A/PPP2R1A/DRG1/STAG1/PBRM1/RAB11A/NUDC/NUP62/SMC1A/SEH1L\n\n\n\n\n\nAgain, you can visualize the results in many ways. With the script below you can get an overview of the top 10 enriched pathways and the top 10 repressed pathways.\n\ndata &lt;- gsea_ucd_ctrl\nn &lt;- 10\n\ndata_plot &lt;- arrange(as.data.frame(data@result), desc(abs(NES))) %&gt;%\n    group_by(sign(NES)) %&gt;%\n    dplyr::slice(1:n)\n\nggplot(data_plot, showCategory = n*2,\n      aes(NES, fct_reorder(Description,NES), fill = -log10(p.adjust))) +\ngeom_col() +\ngeom_vline(xintercept = 0, colour = '#696969', linetype = 'dashed') +\nscale_fill_gradientn(colours=c(\"#b3eebe\", \"#46bac2\", \"#371ea3\"),\n                      guide=guide_colorbar(reverse=TRUE)) +\nlabs(x = 'Normalized Enrichment Score',\n     y = '') +\ndefault_theme() +\ntheme(text = element_text(size = 11))\n\n\n\n\n\n\n\n\nAnother interesting way of visualizing the GSEA results is the “running score” plot. For a given pathway, this plot shows the position of the genes in the ranked list and the enrichment score.\n\ngseaplot(gsea_ucd_ctrl, geneSetID = 1, title = gsea_ucd_ctrl$Description[1])\n\n\n\n\n\n\n\n\nNote the differences between the two methods, they won’t always give you the same results. Keep the differences between the two methods in mind when doing your analysis and interpreting the results.\nNow that you are familiar with the basics of RNA-sequencing analysis, have fun analyzing the data you generated during the week in the lab :)\n\n\nsessionInfo()\n\nR version 4.4.1 (2024-06-14)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS 15.6\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.4-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Europe/Amsterdam\ntzcode source: internal\n\nattached base packages:\n[1] stats4    stats     graphics  grDevices datasets  utils     methods  \n[8] base     \n\nother attached packages:\n [1] forcats_1.0.0            variancePartition_1.36.3 BiocParallel_1.40.2     \n [4] reshape2_1.4.4           RColorBrewer_1.1-3       pheatmap_1.0.13         \n [7] biomaRt_2.62.1           purrr_1.1.0              ggrepel_0.9.6           \n[10] viridis_0.6.5            viridisLite_0.4.2        ReactomePA_1.50.0       \n[13] org.Hs.eg.db_3.20.0      AnnotationDbi_1.68.0     IRanges_2.40.1          \n[16] S4Vectors_0.44.0         Biobase_2.66.0           BiocGenerics_0.52.0     \n[19] enrichplot_1.26.6        clusterProfiler_4.14.6   edgeR_4.4.2             \n[22] limma_3.62.2             patchwork_1.3.1          stringr_1.5.1           \n[25] knitr_1.50               ggplot2_3.5.2            tidyr_1.3.1             \n[28] dplyr_1.1.4             \n\nloaded via a namespace (and not attached):\n  [1] jsonlite_2.0.0          magrittr_2.0.3          ggtangle_0.0.7         \n  [4] nloptr_2.2.1            farver_2.1.2            rmarkdown_2.29         \n  [7] fs_1.6.6                zlibbioc_1.52.0         vctrs_0.6.5            \n [10] minqa_1.2.8             memoise_2.0.1           ggtree_3.14.0          \n [13] htmltools_0.5.8.1       progress_1.2.3          curl_6.4.0             \n [16] broom_1.0.9             gridGraphics_0.5-1      KernSmooth_2.23-24     \n [19] pbkrtest_0.5.5          plyr_1.8.9              httr2_1.2.1            \n [22] cachem_1.1.0            igraph_2.1.4            iterators_1.0.14       \n [25] lifecycle_1.0.4         pkgconfig_2.0.3         Matrix_1.7-0           \n [28] R6_2.6.1                fastmap_1.2.0           gson_0.1.0             \n [31] rbibutils_2.3           GenomeInfoDbData_1.2.13 numDeriv_2016.8-1.1    \n [34] digest_0.6.37           aplot_0.2.8             RSQLite_2.4.2          \n [37] labeling_0.4.3          filelock_1.0.3          httr_1.4.7             \n [40] polyclip_1.10-7         compiler_4.4.1          aod_1.3.3              \n [43] bit64_4.6.0-1           withr_3.0.2             backports_1.5.0        \n [46] graphite_1.52.0         DBI_1.2.3               gplots_3.2.0           \n [49] ggforce_0.5.0           R.utils_2.13.0          MASS_7.3-60.2          \n [52] rappdirs_0.3.3          corpcor_1.6.10          caTools_1.18.3         \n [55] gtools_3.9.5            tools_4.4.1             ape_5.8-1              \n [58] remaCor_0.0.18          R.oo_1.27.1             glue_1.8.0             \n [61] nlme_3.1-164            GOSemSim_2.32.0         grid_4.4.1             \n [64] fgsea_1.32.4            generics_0.1.4          gtable_0.3.6           \n [67] R.methodsS3_1.8.2       data.table_1.17.8       hms_1.1.3              \n [70] tidygraph_1.3.1         xml2_1.3.8              XVector_0.46.0         \n [73] pillar_1.11.0           yulab.utils_0.2.1       splines_4.4.1          \n [76] tweenr_2.0.3            BiocFileCache_2.14.0    treeio_1.30.0          \n [79] lattice_0.22-6          renv_1.0.9              bit_4.6.0              \n [82] tidyselect_1.2.1        GO.db_3.20.0            locfit_1.5-9.12        \n [85] Biostrings_2.74.1       reactome.db_1.89.0      reformulas_0.4.1       \n [88] gridExtra_2.3           RhpcBLASctl_0.23-42     xfun_0.53              \n [91] graphlayouts_1.2.2      statmod_1.5.0           matrixStats_1.5.0      \n [94] stringi_1.8.7           UCSC.utils_1.2.0        boot_1.3-30            \n [97] lazyeval_0.2.2          ggfun_0.2.0             yaml_2.3.10            \n[100] evaluate_1.0.4          codetools_0.2-20        ggraph_2.2.1           \n[103] tibble_3.3.0            qvalue_2.38.0           graph_1.84.1           \n[106] ggplotify_0.1.2         cli_3.6.5               Rdpack_2.6.4           \n[109] Rcpp_1.1.0              GenomeInfoDb_1.42.3     EnvStats_3.1.0         \n[112] dbplyr_2.5.0            png_0.1-8               parallel_4.4.1         \n[115] blob_1.2.4              prettyunits_1.2.0       DOSE_4.0.1             \n[118] bitops_1.0-9            lme4_1.1-37             mvtnorm_1.3-3          \n[121] tidytree_0.4.6          lmerTest_3.1-3          scales_1.4.0           \n[124] crayon_1.5.3            fANCOVA_0.6-1           rlang_1.1.6            \n[127] cowplot_1.2.0           fastmatch_1.1-6         KEGGREST_1.46.0"
  }
]